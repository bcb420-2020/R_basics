--- 
title: "BCB420 - Computational System Biology"
subtitle: "R - Basics"
author: "Main author: Boris Steipe; Modified: Ruth Isserlin"
date: "last modified `r Sys.Date()`"
site: bookdown::bookdown_site
output:   bookdown::gitbook
documentclass: book
bibliography: [book.bib, packages.bib]
biblio-style: apalike
link-citations: yes
github-repo: bcb420-2020/R_basics
description: "Prerequisite work for U of T course BCB420 - Computational System Biology"
download: ["epub"]
edit : https://github.com/bcb420-2020/R_basics/edit/master/%s
history: https://github.com/bcb420-2020/R_basics/commits/master/%s
view:  https://github.com/bcb420-2020/R_basics/blob/master/%s
---

# About

Original content for this book was created by [Boris Steipe](http://biochemistry.utoronto.ca/person/boris-steipe/) from [Boris Steipe BCB420 wiki resources](http://steipe.biochemistry.utoronto.ca/abc/index.php/Computational_Systems_Biology_Main_Page) licensed under ![](images/cc_icon.png) [CC BY 4.0](https://creativecommons.org/licenses/by/4.0/). 

## Attributions:

This book was created using The **bookdown** package and can be installed from CRAN or Github:

```{r eval=FALSE}
install.packages("bookdown")
# or the development version
# devtools::install_github("rstudio/bookdown")
```

```{r include=FALSE}
#initialize the task counter
task_counter <- 0
```


Icons are from the [“Very Basic. Android L Lollipop” set by Ivan Boyko](https://www.iconfinder.com/iconsets/very-basic-android-l-lollipop) licensed under [CC BY 3.0](https://creativecommons.org/licenses/by/3.0/). 

<!--chapter:end:index.Rmd-->

#Installing R and RStudio {#r_install}
(Notation; installing R and RStudio; packages; first experiments.)
 
 
## Overview 
###Abstract:
This unit works through the installation of R and RStudio and introduces R's packages of additional functions.

### Objectives:
This unit will:

  * guide you through first steps for installing R and R Studio on your own computer; and
  * introduce the concept of "packages" to extend R's functionality;

### Outcomes:
After working through this unit you:

  * have a working installation of R and RStudio and know how to start RStudio;
  * can find and install packages.

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites:
This unit builds on material covered in the following prerequisite units:

[ABC-Insights (insights!)]()<br>
[FND-Biocomputing_setup (Computer Setup for Biocomputing)]()<br>
 
## R
 
### Introduction

The [R statistics environment and programming language](https://en.wikipedia.org/wiki/R_(programming_language)) is an exceptionally well engineered, free (as in free speech) and free (as in free beer) platform for data manipulation and analysis. The number of functions that are included by default is large, there is a very large number of additional, community-generated analysis modules that can be simply imported from dedicated sites (e.g. the [Bioconductor](https://www.bioconductor.org/) project for molecular biology data), or via the CRAN network, and whatever function is not available can be easily programmed. The ability to filter and manipulate data to prepare it for analysis is an absolute requirement in research-centric fields such as ours, where the strategies for analysis are constantly shifting and prepackaged solutions become obsolete almost faster than they can be developed. Besides numerical analysis, R has very powerful and flexible functions for plotting graphical output.
 
 
**Note: you can't learn a programming language in a single day.**

Work through this material unit by unit, but when you are done, you need constant repetition to bring it into active memory. And make sure you understand every step. Taking shortcuts and/or cramming everything in a single, desperate effort is a waste of your time.
 
 
### Before you begin: Notation and Formatting

In this tutorial, I use specific notation and formatting to mean different things:

  * If you see footnotes^[and when you click on the arrow to the left, this will take you back to where you came from], click on the number to read more.
  * This is normal text for explanations. It is written in a proportionally spaced font.
  
```{r, eval=FALSE}
Code formatting is for code examples, file- and function names, directory paths etc. Code is written in a monospaced font^[Proportional fonts are for elegant document layout. Monospaced fonts are needed to properly align characters in columns. For code and sequences, we alway use monospaced font. Code editors always use monospaced fonts, but since I need to eMail a lot of code and sequences, I have also set my eMail client to use monospaced font by default (Courier, or Monaco). I highly encourage you to do the same.].
```
  
  * **Bold emphasis** and <u>underlining</u> are to mark words as particularly important.
  * Examples of the right way to do something are <span style="background-color: #a9f08d">highlighted green</span>.
  * Examples of the wrong way to do something are <span style="background-color: #f0948d">highlighted red</span>.
 
`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Tasks and exercises are described in boxes with a blue background. You have to do them, they are not optional. If you have problems, you must contact your instructor, or discuss the issue on the mailing list. Don't simply continue. All material builds on previous material, and evaluation is cumulative.
```

```{block, type="rmd-troubleshooting"}
These sections have information about issues I encounter more frequently. They are required reading when you need to troubleshoot problems but also give background information that may be useful to avoid problems in the first place.
```

### "Metasyntactic variables"
When I use notation like <Year> in instructions, you type the year, the whole year and nothing but the year (e.g the four digits 2017). You never type the angle brackets! I use the angle brackets only to indicate that you should not type Year literally, but substitute the correct value. You might encounter this notation as <path>, <filename>, <firstname lastname> and similar. To repeat: if I specify

```{r, eval=FALSE}
<your name>
```
... and your name is Elcid Barrett, You type

```{r, eval=FALSE}
Elcid Barrett
```

... and not   <span style="background-color: #f0948d">your name</span>   or   <span style="background-color: #f0948d">\<Elcid Barret\></span>   or similar. (Oh the troubles I've seen ...)
 
The sample code on this page sometimes copies text from the console, and sometimes shows the actual commands only. The > character at the beginning of the line is always just R's input prompt, it tells you that you can type something now - you never actually type > at the beginning of a line. If you read:

```{r, eval=FALSE}
> getwd()
```

you need to type:

```{r, eval=FALSE}
getwd()
```
 
If a line starts with [1] or similar, this is **R**'s output on the console.^[[1] means: the following is the first (often only) element of a vector.] The # character marks the following text as a comment which is not executed by R. These are lines that you do not type. They are program output, or comments, not commands. 

### Characters
Different characters mean different things for computers, and it is important to call them by their right name.

  * /  ◁ this is a forward-slash. It leans forward in the reading direction.
  * \\  ◁ this is a backslash. It leans backward in the reading direction.
  * ( )  ◁ these are parentheses.
  * [ ]  ◁ these are (square) brackets.
  * < >  ◁ these are angle brackets.
  * { }  ◁ these are (curly) braces.
  *  "  ◁ this, and only this is a quotation mark or double quote. All of these are not: <span style="background-color: #f0948d">“”„«» </span>. They will break your code. Especially the first two are often automatically inserted by MSWord and hard to distinguish.^[Never, ever edit code in MS Word. Use R or RStudio. Actually, don't use notepad or TextEdit either.]
  * '  ◁ this, and only this is a single quote. All of these are not: <span style="background-color: #f0948d">‘’‚‹› </span> . They will break your code. Especially the first two are often automatically inserted by MSWord and hard to distinguish.
  

```{block type="rmd-caution"}
**MSWord is not useful as a code editor.**
```
 
 
## The environment
In this section we discuss how to download and install the software, how to configure an R session and how to work in the R environment.
 
 
## Install R

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}

  * Navigate to [CRAN (the Comprehensive R Archive Network)](https://cran.r-project.org/) ^[You can also use one of the mirror sites, if CRAN is down - for example the mirror site at the University of Toronto. A choice of mirror sites is listed on the R-project homepage.] and follow the link to Download R for your computer's operating system.
  * Download a precompiled binary (or "build") of the R "framework" to your computer and follow the instructions for installing it. Make sure that the program is the correct one for your version of your operating system.
  * Launch R.
  * Once you see that R is running correctly, you may quit the program for now.
```

The program should open a window–this window is called the "R console" – and greet you with its input prompt, awaiting your input:

```{r, eval = FALSE}
>
```


```{block, type="rmd-troubleshooting"}

**I can't install R.**

  * Make sure that the version you downloaded is the right one for your operating system. 
  * Also make sure that you have the necessary permissions on your computer to install new software.
  
```
 

### Install RStudio

[RStudio](https://rstudio.com/) is a free IDE (Integrated Development Environment) for **R**. RStudio is a wrapper^[A "wrapper" program uses another program's functionality in its own context. RStudio is a wrapper for **R** since it does not duplicate **R**'s functions, it runs the actual R in the background.] for **R** and as far as basic R is concerned, all the underlying functions are the same, only the user interface is different (and there are a few additional functions that are very useful e.g. for managing projects).

Here is a small list of differences between **R** and RStudio.

**pros (some pretty significant ones actually):**

  * Integrated version control.
  * Support for "projects" that package scripts and other assets.
  * Syntax-aware code colouring.
  * A consistent interface across all supported platforms. (Base R GUIs are not all the same for e.g. Mac OS X and Windows.)
  * Code autocompletion in the script editor. (Depending on your point of view this can be a help or an annoyance. I used to hate it. After using it for a while I find it useful.)
  * "Function signaturtes" (a list of named parameters) displayed when you hover over a function name.
  * The ability to set breakpoints for debugging in the script editor.
  * Support for knitr, and rmarkdown; also support for R notebooks ... (This supports "literate programming" and is actually a big advance in software development)
  * Support for R notebooks.

**cons (all minor actually):**

  * The tiled interface uses more desktop space than the windows of the R GUI.
  * There are sometimes (rarely) situations where R functions do not behave in exactly the same way in RStudio.
  * The supported R version is not always immediately the most recent release.

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
  * Navigate to the RStudio Website.
  * Find the right version of the RStudio Desktop installer for your computer, download it and install the software.
  * Open RStudio.
  * Focus on the bottom left pane of the window, this is the "console" pane.
  * Type getwd().
  * This prints out the path of the current working directory. Make a (mental) note where this is. We usually always need to change this "default directory" to a project directory.
``` 
 
 
### Packages

R has many powerful functions built in, but one of it's greatest features is that it is easily extensible. Extensions have been written by legions of scientists for many years, most commonly in the R programming language itself, and made available through [CRAN–The Comprehensive R Archive Network](https://cran.r-project.org/) or through the [Bioconductor project](http://www.bioconductor.org/).

A package is a collection of code, documentation and (often) sample data. To use packages, you need to install the package (once). You can then use all of the package's functions by prefixing them with the package name and a double colon (eg. package::function()); that's the preferred way. Or you can load all of the package's functions with a library(package) command, and then use the functions without a prefix. That's less typing, but it's also less explicit and you may end up constantly wondering where exactly a particular function came from. In the teaching code for this course, I use the package::function() idiom wherever reasonable.

You can get an overview of installed and loaded packages by opening the Package Manager window from the Packages & Data Menu item. It gives a list of available packages you currently have installed, and identifies those that have been loaded at startup, or interactively. But note, a package does not have to be loaded to be used.
 
`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
  * Navigate to [http://cran.r-project.org/web/packages/](https://cran.r-project.org/web/packages/) and read the page.
  * Navigate to [http://cran.r-project.org/web/views/](http://cran.r-project.org/web/views/) (the curated CRAN task-views).
  * Follow the link to [Genetics](https://cran.r-project.org/web/views/Genetics.html) and read the synopsis of available packages. The library sequinr sounds useful, but check first whether it has been installed.
  * Follow the exercise below
```

  * library() opens a window that lists the packages that are installed on your computer;

```{r library}
library()
```

  * search() shows which one are currently loaded.

```{r search}
search()
```
 
  * In the **Packages tab** of the lower-right pane in RStudio, confirm that seqinr is not yet installed.
  * Follow the link to [seqinr](https://cran.r-project.org/web/packages/seqinr/index.html) to see what standard information is available with a package. Then follow the link to the [Reference manual](http://cran.r-project.org/web/packages/seqinr/seqinr.pdf) to access the documentation pdf. This is also sometimes referred to as a "vignette" and contains usage hints and sample code.
  * Read the help for vignette. Note that there is a command to extract R sample code from a vignette, to experiment with it.
  
```{r vignette}
?vignette
```

  * Install seqinr from the closest CRAN mirror and load it for this session. Explore some functions.

```{r install}
?install.packages
```

```{r}
install.packages("seqinr",repos="https://cran.rstudio.com/")   # Note: the parameter is a quoted string!
```

```{r help_pkg}
library(help="seqinr") # this will launch a new window with the seqinr package info
```

```{r ls}
#Note: the file must be attached in order for the below function to work 
library(seqinr)
ls("package:seqinr")
```

```{r function_a}
?seqinr::a #In Rstudio this will open the method description in the Help panel
```

```{r function_a_ex}
seqinr::a("Tyr")
```

```{r function_words_ex}
seqinr::words(3, c("A", "G", "C", "U"))
```

```{block, type="rmd-troubleshooting"}

**The installation fails.** 
  * **You might see an error message such as this:**
  
<font color="red">Warning message:</font><br>
<font size="3" color="red">package ‘XYZ’ is not available (for R version 3.2.2)</font>

  * This can mean several things:
    * The package is not available on CRAN. Try Bioconductor instead or Google for the name to find it.
    * The package requires a newer version of R than the one you have. Upgrade, or see if a legacy version exists.
    * A comprehensive set of reasons and their resolution is here on [stackoverflow](https://stackoverflow.com/questions/25721884/how-should-i-deal-with-package-xxx-is-not-available-for-r-version-x-y-z-wa).


  * **We have seen the following on Windows systems when typing library(help="seqinr")**
<font color="red">Error in formatDL(nm, txt, indent = max(nchar(nm, "w")) + 3) :</font><br>
<font color="red">incorrect values of 'indent' and 'width'</font><br>

    * Anecdotally this was due to a previous installation problem with a mixup of 32-bit and 64-bit R versions, although another student told us that the problem simply went away when trying the command again. Whatever: Make sure you have the right R version installed for your operating system. Uninstall and reinstall when in doubt. Conflicting libraries can be the source of strange misbehaviour.
```
 
The fact that these methods work, shows that the package has been downloaded, installed, its functions are now available with the package name prefix and any datasets it contains can be loaded. Just like many other packages, seqinr comes with a number of datafiles. Try:


```{r function_data}
?data
```


```{r function_data_seqinr}
data(package="seqinr")            # list the available data
```

```{r load_aaindex}
data(aaindex, package="seqinr")   # load ''aaindex''
```

```{r about_aaindex}
?aaindex                          # what is this?
```

```{r show_aaindex_ex1}
aaindex$FASG890101                # two of the indices ...
```

```{r show_aaindex_ex2}
aaindex$PONJ960101
```

Lets use the data: plot amino acid single-letter codes by hydrophobicity and volume. The values come from the dataset. Copy and paste the commands, we'll discuss them in detail later.
 
```{r plot_hydrophobicity}
plot(aaindex$FASG890101$I,
     aaindex$PONJ960101$I,
     xlab="hydrophobicity", ylab="volume", type="n")
text(aaindex$FASG890101$I,
     aaindex$PONJ960101$I,
     labels=a(names(aaindex$FASG890101$I)))
```

 
Now, just for fun, let's use seqinr package functions to download a sequence and calculate some statistics (however, not to digress too far, without further explanation at this point). Copy the code below and paste it into the R-console.

```{r full_ex1_sequinr, eval=FALSE, echo=TRUE}
seqinr::choosebank("swissprot")
mySeq <- seqinr::query("mySeq", "N=MBP1_YEAST")
mbp1 <- seqinr::getSequence(mySeq)
seqinr::closebank()
x <- seqinr::AAstat(mbp1[[1]])
barplot(sort(x$Compo), cex.names = 0.6)
```

We could have "loaded" the package with library(), and then used the functions without prefix. Less typing, but also less explicit.

```{r full_ex2_sequinr, eval=FALSE, echo=TRUE}

library(seqinr)
choosebank("swissprot")
mySeq <- query("mySeq", "N=MBP1_YEAST")
mbp1 <- getSequence(mySeq)
closebank()
x <- AAstat(mbp1[[1]])
barplot(sort(x$Compo), cex.names = 0.6)

```

In general we will be using the idiom with the package prefix throughout the course.
 
The function **requireNamespace()** is useful because it does not produce an error when a package has not been installed. It simply returns TRUE if successful or FALSE if not. Therefore one can use the following code idiom in R scripts to avoid downloading the package every time the script is called.

```{r req_namespace}
if (! requireNamespace("seqinr", quietly=TRUE)) {
  install.packages("seqinr")
}
```


**You can get package information with the following commands:**

```{r}
library(help = seqinr)       # basic information
```

```{r}
browseVignettes("seqinr")    # available vignettes
```

```{r}
data(package = "seqinr")     # available datasets
```

  * **Note** that install.packages() takes a (quoted) string as its argument, but library() takes a variable name (without quotes). New users usually get this wrong :-)
  * **Note** that the Bioconductor project has its own installation system, the Biocmanager::install() function. It is explained [here](https://bioconductor.org/install/).
  * **Note**, just to mention it at this point: to install packages that are not on CRAN or Bioconductor, you need the [devtools package](https://www.r-project.org/nosvn/pandoc/devtools.html).
 
 
### Finding packages
One of the challenges of working with R is the overabundance of options. CRAN has over 10,000 packages and Bioconductor has over 1,300 more. How can you find ones that are useful to your work? There's actually a package to help you do that, the sos package on CRAN. Try this:
```{r find_packages,eval=FALSE}
if (! requireNamespace("sos", quietly=TRUE)) {
    install.packages("sos")
}
library(help = sos)       # basic information
browseVignettes("sos")    # available vignettes
 
sos::findFn("moving average")
```

**Or: **

  * Read a CRAN [Task View](https://cran.r-project.org/web/views/) for your area of interest
  * or the [Bioconductor Views](https://www.bioconductor.org/packages/devel/BiocViews.html);
  * Search on "Metacran" ([ "regex" example here"](https://www.r-pkg.org/search.html?q=regex)) ...
  * or "MRAN" (["regex" example here"](https://mran.microsoft.com/packages?search=regex), not that the results are not identical);
  * and, as always, Google.
 
 
### Self-evaluation
  1. Question 1 - What is the purpose of this code?
```{r eval=FALSE}
if (! requireNamespace("seqinr", quietly = TRUE)) {
    install.packages("seqinr")
}
```

Why not just use:
```{r eval=FALSE}
 install.packages("seqinr")
```

**Answer**:
This code idiom is useful in scripts, to ensure a package is installed before we try to use its functions. If we would simply use install.packages("seqinr"), the package would be downloaded from CRAN every time the script is run. That would make our script slow, and require available internet access for the script to run.

In the code above, the package is downloaded only when requireNamespace() returns FALSE, which presumably means the package has not yet been downloaded.

### Further reading, links and resources
[Wikipedia article](https://en.wikipedia.org/wiki/R_(programming_language)) on the R statistics environment and programming language
[The R project homepage](https://www.r-project.org/)
[The R Studio IDE](https://rstudio.com/products/rstudio/)
[CRAN–The Comprehensive R Archive Network](https://cran.r-project.org/)
[The Bioconductor project homepage](http://www.bioconductor.org/)
[R bloggers](https://www.r-bloggers.com/)
[Package finding strategies (Revolutions Analytics Blog)](https://blog.revolutionanalytics.com/2017/01/cran-10000.html)
[Intro to R packages](https://www.datacamp.com/community/tutorials/r-packages-guide) (at DataCamp).
["The Impressive Growth of R" (Stackoverflow Data Analytics Team Blog)](https://stackoverflow.blog/2017/10/10/impressive-growth-r/)
[Ten simple rules for biologists learning to program](https://journals.plos.org/ploscompbiol/article?id=10.1371/journal.pcbi.1005871) - Carey and Papin advise novice biologist programmers how to begin. Much of this paper resonates well with our Introduction to R learning units. Good context for a beginning, to get a sense of where we are going with this.
 
 
 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2019-01-07<br>
Version: 1.1<br>
**Version history**:<br>
1.1 Change from require() to requireNamespace() and use <package>::<function>() idiom.<br>
1.02 Maintenance<br>
1.0.1 Removed mention of Sweave - obsolete, and broken link. Added mention of "literate programming".<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 

### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:01-R-installation.Rmd-->

#Setup R to work with it {#r-setup}
(R projects; working with git version control via RStudio; the history mechanism and why not to use it; .Rprofile to customize startup behaviour; the working directory.)

## Overview
###Abstract:
This unit discusses the setup of a working session with RStudio.

### Objectives:

This unit will:

  * introduce R projects;
  * start working with git version control via RStudio;
  * discuss the history mechanism and why not to use it;
  * mention .Rprofile to customize startup behaviour; and
  * teach you to define the Working Directory of an R session.

### Outcomes:

After working through this unit you:

  * have verified that you can install R projects from GitHub;
  * know what the .Rprofile file is for;
  * can get and set the path of the current Working Directory.
  
### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Installation (Installing R and RStudio)](#r_install)


## Your Course Folder

Your Course Folder should already exist.

Take note! When you write a Windows paths in an R command, you have to use the "wrong" forward slash to separte directories and files. R will translate these "Unix-style"" paths into Windows-style paths automatically when it negotiates with the operating system. But the backslash is interpreted as an "escape" character that gives the character the follows it a special meaning.^[For example C:Documents\new would be interpreted as C:Documents<linebreak>ew because \n is the linebreak character. Even though that's actually the path name on Windows, in an R command you have to write C:Documents/new]

**Folder name and path examples**<br>

<span style="background-color: #a9f08d">/Users/Pierette/Documents/BCB420</span>  ◁ Looking good on a Mac.

<span style="background-color: #a9f08d">C:\Users\Pulcinella\Documents\CBW</span>  ◁ Looking good on a Windows computer.

<span style="background-color: #a9f08d">"C:/Users/Pulcinella/Documents/CBW"</span>  ◁ Looking good inside R on a Windows computer (note the quotation marks!).

<span style="background-color: #f0948d">C:\Users\Pantalone\Documents\BCH1441 (2017)</span>  ◁ Wrong. No special characters please.

<span style="background-color: #f0948d">/Users/Brighella/Documents/UofT Stuffz/Courses/more/Comp Sys biol. course </span> ◁ Wrong. Please read instructions more carefully.

<span style="background-color: #f0948d">C:\Users\Tartaglia\Documents\KUWTK\<Coursecode></span>  ◁ I can't even ...

 
## "Projects"

We will make extensive use of "projects" in class. Read more about projects in RStudio [here](https://support.rstudio.com/hc/en-us/articles/200526207-Using-Projects).
 
## Git Version control

We will also make extensive use of version control. In fact, we will now load a project via Git version control from its free, public repository on [GitHub](https://github.com/).

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
  * Read more about [Version Control in RStudio here](https://support.rstudio.com/hc/en-us/articles/200532077-Version-Control-with-Git-and-SVN).
  * Follow the instructions to install git on your computer.
  
Then do the following:

  * open RStudio
  * Select File → NewProject...
  * Click on Version Control
  * Click on Git
  * Enter https://github.com/hyginn/R_Exercise-BasicSetup as the Repository URL.
  * Type a <tab> character, the Project directory name field should then autofill to read R_Exercise-BasicSetup
  * Click on Browse... to find your Course Folder. (The one that you have already created).   * Click Open.
  * Click Create Project; the project files should be downloaded and the console should prompt you to type init() to begin.
  * Type init() into the console pane.
  * An R script should load.
  * Explore the script and follow its instructions.
```


```{block, type="rmd-troubleshooting"}
  1. I get an error message: **"Git not found".**
    * The simplest reason is that you may have had RStudio open while installing git. Just restart RStudio.
    * The executable for Git (the Git "program" - "git.exe" on Windows, "git" elsewhere) needs to be on your system's path, or correctly specified in RStudio's options. The correct "path" to Git will depend on your operating system, and how git was installed. To find where git is installed –
    * On Mac and Unix systems, open a Terminal window^[The Terminal app is in the Utilities sub-folder of your Applications folder.] and type which git. This will either print the path (Yay), or tell you that git is not found. The latter could have two reasons: either git has no been installed in the first place, or it has been installed in a non-standard location by whatever installation manager you have used. Ask Google to help you figure out how to solve your specific case.
    * On Windows you can find the location of the executable by searching "git.exe" in your "programs and files". Once it's been found, right click on it and select "Open file location" from the options. It might be in C:\Program Files\Git\cmd\git.exe but the exact location depends on your operating system.
    * Once you know the path to your git executable, open File → Preferences, click on the Git/SVN option, click on the Browse button, and find the correct folder. On Macs you may need to click <shift> <command> G to open the "Go to ..." dialogue, then type the top-folder of the path (e.g. /usr) and click your way down to folder where the program lives. Find the installation directory and select git.exe. Then click "ok".
    * Then try again to create the project and let us know what happened in case it still did not work.

 
  1. **I get an error message like "directory exists and is not empty".**
  
    * A directory with the name of the project already exists in the location in which you are asking RStudio to create the project (the Course Folder). Either delete the existing directory, or install the project into a different parent directory.

 
  1. The git icon has disappeared.
    * I have seen this happen when somehow the path to git has changed.
      a. Make sure the correct path to git is set in your File → Preferences → Git/SVN.
      a. Open Tools → Project options... → Git/SVN. Next to Version control system git must be selected, not (None). If it is (None), change this to git. If that's not an option, the path is not correct. Go back to (A).
      a. I think you may need to restart RStudio then and reload your project via the Files → Recent projects... menu for the git icon and the version control options to reappear.

```

 
## Working directory

To locate a file in a computer, one has to specify the filename and the directory in which the file is stored; this is also called the path of the file. However R uses a default "working directory"", which is assumed if no path is specified. This "working directory" for R is either the directory in which the R-program has been installed, or some other directory, that has been defined in a startup script, or specifically defined with the command setwd("<working Directory>") at any time. You can execute the command getwd() to list what the Working Directory is currently set to:


```{r}
getwd()
```

In RStudio, the contents of the working directory is listed in the Files Pane (lower-right).

It is convenient to put all your R-input and output files into a project specific directory and then define this to be the "Working Directory". Use the setwd() command for this. setwd() requires an argument that you type between the parentheses: a string with the directory path, or a variable containing such a string. Strings in R are delimited with " or ' characters. If the directory does not exist, an Error will be reported. Make sure you have created the directory. On Mac and Unix systems, the usual shorthand notation for relative paths can be used: ~ for the home directory, . for the current directory, .. for the parent of the current directory.

If you use a Windows system, you need know that backslashes – "\" – have a special meaning for R, they work as escape characters. For example the string "\n" means newline, and "\t" means tab. Thus R gets confused when you put backslashes into string literals, such as Windows path names. R has a simple solution: you simply use forward slashes instead of backslashes when you specify paths, and R will translate them correctly when it talks to your operating system. Instead of C:\documents\projectfiles you write C:/documents/projectfiles. Also note that on Windows the ~ tilde is a shorthand for the directory in which R is installed, not the user's home directory.


My home directory...

```{r}
setwd("~") # Note: ~ is the "tilde" - the squiggly line - not the straight hyphen
getwd()
```

Relative path: home directory, up one level, then down into baderlab's home directory)

```{r}
setwd("~/../baderlab")
getwd()
```

Absolute path: specify the entire string)
```{r}
setwd("/Users/ruthisserlin/Documents")
getwd()
```


In RStudio you can use the Session → Set Working Directory menu. This includes the useful option to set the current project directory as the working directory ^[Projects that I create for teaching are configured to use this option by default, thus once the project is loaded, the Working Directory should already be correctly set.].

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}

  * Since you have gone through the script of the BasicSetup project, your working directory should be set to this project directory (I have configured the project to do this automatically.)
  * Figure out the path to its parent directory - i.e. the course- or workshop directory you created at the beginning.
  * Use setwd("<your/path/and/directory/name>") to set the Working Directory to the Course Folder.
  * Confirm that this has worked by typing getwd() and list.files().
  * The Working Directory functions can also be accessed through the Menu, under Misc.

```

## .Rprofile - startup commands

Often, when working on a project, you would like to start off in your working directory right away when you start up R, instead of typing the setwd() command. This is easily done in a special R-script that is executed automatically on startup^[Actually, the first script that runs is Rprofile.site which is found on Linux and Windows machines in the C:\Program Files\R\R-{version}\etc directory. But not on Macs.]. The name of the script is .Rprofile and R expects to find it in the user's home directory. You can edit these files with a simple text editor like Textedit (Mac), Notepad (windows) or Gedit (Linux) - or, of course, by opening it in RStudio - don't forget that a code editor is also a text editor^[Operating systems commonly hide files whose name starts with a period "." from normal directory listings. All files however are displayed in RStudio's File pane. Nevertheless, it is useful to know how to view such files by default. On Macs, you can configure the Finder to show you such "hidden files" by default. To do this: (i) Open a terminal window; (ii) Type: $defaults write com.apple.Finder AppleShowAllFiles YES (iii) Restart the Finder by accessing Force quit (under the Apple menu), selecting the Finder and clicking Relaunch. (iV) If you ever want to revert this, just do the same thing but set the default to NO instead.].

Besides setting the working directory, other items that might go into such a file could be

  * libraries that you often use
  * constants that are not automatically defined
  * functions that you would like to preload.

For more details, use R's help function:
```{r}
?Startup
```

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Just for information:

  * locate the .Rprofile file in the RStudio file pane;
  * click on it to open it in the text-editing window.
  * This way you could change it and save the changes. However, don't do that now but Close the file again.
```
 

## The "Workspace"
During an R session, you might define a large number of R-objects: variables, data structures, functions etc., and you might load packages and scripts. All of this information is stored in the so-called "Workspace". When you quit R you have the option to save the Workspace; it will then be restored in your next session. Now, you might think: how convenient - I can just stop R, and when I restart it, it will go into the same state as it was. But no. Restoring the Workspace from a previous state is actually a bad idea: if you load data or variables in a startup script, they may be overwritten with a corrupted version that you happened to save in the workspace when you last quit. This is very hard to troubleshoot. Essentially, when you save and reload your Workspace habitually, you have overlapping and potentially conflicting behaviour of startup script and Workspace restore.

What I recommend instead is the following:

  * Never save the Workspace.
  * Always work from scripts.
  * Write your scripts so that you can easily recreate all objects you need to continue your analysis.
  * If some objects are expensive to compute, you can always save() and later load() them explicitly. In fact, restoring the Workspace does the same thing, but you have less control regarding whether the version of your objects are correct, and what temporary variables may be loaded as well.
  * In this way, you work with explicit instructions, not implicit behaviour.
  * Explicit beats implicit.

List the current workspace contents: initially it only contains the init() function that was loaded from the .Rprofile script on startup.

```{r}
ls()
```

Initialize three variables

```{r}
a <- 3
b <- 4
c <- sqrt(a^2 +b^2)
ls()
```

Save one item in an .RData file.
```{r}
save(a, file = "tmp.RData")
```

Remove one item from the Workspace. (Note: the argument for rm() is not the string "a", but the variable name a. No quotation marks!)

```{r}
rm(a)
ls()
```

Load what you previously saved.

```{r}
load("tmp.RData")
ls()
```

Note: you can save() more than one item in an .RData file. When you then load() the file, all of the objects it contains are loaded. You don't assign these objects - they are being restored.


We can use the output of ls() as input to rm() to remove all items from the workspace. (cf. ?rm for details)

```{r}
rm(list = ls())
ls()
```

The contents of the workspace is displayed in RStudio's Environment Pane (top-right). You can see a little "broom" icon at the top that you can click to remove all items from the workspace.

## Self-evaluation

##Further reading, links and resources
 


 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2019-01-07<br>
Version: 1.1.1<br>
**Version history**:<br>
1.1.1 Maintenance<br>
1.1 Fixed display bug with "=" in template code; moved to GeSHi formatting.<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 
 

### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:02-R-setup.Rmd-->

# Console and scripts {#r-console}
(Code interactively or fom scripts.)

## Overview
### Abstract:
This unit discusses use working from the RStudio console vs. working from scripts.

### Objectives:
This unit discusses principles of working interactively vs. working from scripts.

### Outcomes:
After working through this unit you:

  * are familiar with the advantages of working from script files;
  * should begin always working from script files in your own practice.
  
### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Installation (Installing R and RStudio)](#r_install)

## Typing code or executing it?
The RStudio "console" is the bottom-left pane into which you can type commands for execution, and which will contain the output of print() or cat() commands.

Commands can be:

  * directly typed into the console;
  * copied by you from the Wiki and pasted into the console;
  * or executed from a script (i.e. a text-file of R commands that can run as a program), either by selecting and executing the code, or by executing the entire script with the source("<filename>") command.
  
  However, note the following: **it is convenient to copy/paste code, but you don't learn how to write code through that**. Practice has shown that it is better to actually type commands, even if you are just re-typing code from a book or online. Actively typing out the code character by character ensures you are reading and translating the code, and notice if anything is not entirely clear.^[ We use a predictive mental contents-model when we type - something like an inbuilt autocorrect-suggestion mechanism; thus if you type something unfamiliar or surprising (e.g. a subtle detail of syntax), you will notice and be able to figure out the issue. Pasting code is a merely mechanical activity.] In computer code, every single character matters. For example, I expect that by typing out commands you will be much less likely to confuse = with <- or even ==. Also, you will sometimes mistype and create errors. That's actually good, because you quickly learn to spot errors, fix them, and resume. That way you build confidence.

  Regarding the larger scripts we load from GitHub - these are too long to be retyped. Select the line, or parts of the line, or a larger block of code that you want to execute, then press <command> R, or <command><enter> (depending on your operating system) to execute the selected block. In this case you'll need extra effort to discipline yourself and actually read and **understand** every single character and command. The point is not to execute the scripts. The point is to understand their contents. The best way to do this is to edit the code, vary parameters, try alternatives and in general **play**.

  Actually **working** with code - i.e. developing code for the lab - is another story. In this case scripts are indispensable for development. I type all my **R** code into a script, never directly into the console - in this way it is much easier to come back, change things and recreate whatever analysis I was doing: this is essential for "reproducible research". I type into the script, save the script from time to time, and execute commands from the script, not the console - that's the easiest way to modify and develop. Making script and console work hand in hand is the way to work with **R**. There are four major advantages:

  1. The script is an accurate record of my procedure so I know exactly what I have done;
  1. I add numerous comments, to record what I was thinking when I developed it;
  1. I can immediately reproduce the entire analysis from start to finish, simply by rerunning the script;
  1. I can reuse parts easily, thus making new analyses quick to develop;
  1. If I keep my script under version control, I can return to previous versions and undo errors. These were actually five points.

 
## User interface
Both **R** and RStudio have a GUI^[A GUI is a Graphical User Interface, it has windows and menu items, as opposed to a "command line interface".] to lay out common tasks. For example, there are a number of menu items, many of which are similar to other programs you will have worked with ("File", "Edit", "Format", "Window", "Help" ...). But note: all of these tasks can also be accessed through the command line in the console.

In general, GUIs are useful when you are not sure what you want to do or how to go about it; the command line is much more powerful when you have more experience and know your way around in principle. R gives you both options.

## Self-evaluation
## Further reading, links and resources
 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-04<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:03-R-console.Rmd-->

# Getting help for R {#r-help}
(The internal R help system; other help resources.)

## Overview
### Abstract:
This unit discusses the available Help resources for R programming and develops effective strategies for solving problems.

### Objectives:

This unit will:

  * introduce the inbuilt R help system;
  * point you to useful alternatives;
  * discuss how to write effective questions on technical forums and mailing lists.

### Outcomes:

After working through this unit you:

  * have used the R help system;
  * are able to get help on a function:
    * via R's internal system,
    * via Web searches, or
    * by asking effective questions (including Minimal Working Examples - MWE) on mailing lists.

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Installation (Installing R and RStudio)](#r_install)


## The Help system

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
  * Start RStudio (if it's not already open) and as you work through the sections below, type the commands and explore what they do.
```

If all you need is the correct name of a function (eg. was it list_files(), list.files(), or listFiles()?), just type the first three characters of the function name and use RStudio's autocomplete mechanism to find what you need.

If you are wondering about the parameters of a function, just hover the cursor over the function name in the script pane or the command line in the console and wait a moment: a little window with the function signature will pop up.

But for more detailed information, help is available for all commands as well as for the R syntax. As well, help is available to find the names of commands when you are not sure of them. You can get help through the command line, or from a search field in the Help tab of the lower-right pane.

(help() is a function in R, arguments to a function are passed in parentheses "()")

```{r}
help(rnorm)
```

(shorthand for the same thing)
```{r}
?rnorm
```

(what was the name of that again ... ?)

```{r}
?binom
```

```{r}
??binom
```

(I see "Binomial" in the list of keywords...)

```{r}
?Binomial
```

(Alternatively: use the apropos() function.
```{r}
?apropos
apropos("med")   # all functions that contain the string "med"
apropos("^med")  # all functions that begin with the string
apropos("med$")  # all functions that end with the string
```

If you need help on operators, place them in quotation marks. Try:
```{r}
?"+"
?"~"
?"["
?"%in%"
```

That's all fine, but you will soon notice that **R**'s help documentation is very technical and precise but not all that helpful for newcomers (who need the most help). To illustrate, open the help window for the function var().

```{r}
?var
```

Here's what you might look for:

  * The **Description** section describes the function in general technical terms.
  * The **Usage** section tells you what arguments are required (these don't have defaults), what arguments have defaults, and what the defaults are, and whether additional arguments ("...") are allowed. Often a function comes in several variants, you will find them here.
  * The **Arguments** section provides detailed information . You should read it, especially regarding whether the arguments are single values, vectors, or other objects, and what effect missing arguments will have.
  * The **Details** section might provide common usage and context information. It might also not. Often functions have crucial information buried in an innocuous note here.
  * You really have to read and understand the **Value** section. It explains the output of the function (its returnvalue). The object a function returns could be a list, a matrix or something else (we'll discuss these data types in detail elsewhere.). The value could also be an object that has special methods defined e.g. for plotting it. In that case, the object is formally a "list", and its named "components" can be retrieved with the usual list syntax.
  
If you look at the bottom of the help text, you will usually find examples of the function's usage; these sometimes make matters more clear than the terse and principled help-text above.

What you often won't find:

  * Clear commented, examples that relate to the most frequent use cases.
  * Explanations why a particular function is done in a particular way (e.g. why the denominator is n-1 for sd() and var()).

Notes on common errors:

  * A (reasonably) exhaustive list of alternatives and related functions. There are usually some entries, but there is no guarantee that all alternatives are listed – especially if they are provided by an external package.

Therefore, my first approach for **R** information is usually to Google for what interests me and this is often the quickest way to find working example code. R has a very large user base and it is becoming very rare that a reasonable question will not have a reasonable answer among the top three hits of a Google search. Also, as a result of a Google search, it may turn out that something can't be done (easily) – and you won't find things that can't be done in the help system at all. You may want to include "r language" in your search terms, although Google is usually pretty good at figuring out what kind of "r" you are looking for, especially if your query includes a few terms vaguely related to statistics or programming.

  * There is an active [R-help mailing](https://stat.ethz.ch/mailman/listinfo/r-help) list to which you can post–or at least search the archives: your question probably has been asked and answered before. A number of SIGs (Special Interest Groups) exist for more specific discussions - e.g. for mac OS, geography, ecology etc. They are [listed here](https://stat.ethz.ch/mailman/listinfo).
  * Most of the good responses these days are on stack overflow, discussion seems to be shifting to there from the R mailing list. Information on statistics questions can often be found or obtained from the CrossValidated forum of stackexchange.
    * try this sample search on [stackOverflow...](https://stackoverflow.com/search?q=R+sort+dataframe)
    * try this sample search on [CrossValidated...](https://stats.stackexchange.com/search?q=R+bootstrapping+jackknifing+cross-validation)
  * [Rseek](https://rseek.org/) is a specialized Google search on R-related sites. Try "time series analysis" for an example.
  * The bioconductor project has its own [support site on the Web](https://support.bioconductor.org/).

If you want a quick and constructive answer from the R mailing list or stackoverflow, you must do a bit of homework first. If you ask your question well, you will get incredibly insightful and helpful responses, but you need to help the helpers to help you:

  * Use the dput() function, perhaps combined with head() to create a **small, reproducible dataset** with which your problem can be reproduced or your question illustrated. Keep this as small as possible. Post that. **Don't post screenshots!**
  * Post minimal **code** that reproduces the problem with the data you have supplied. Together the code and data have to form an MWE – a minimal working example. People love to play with your code and get it to work, but they hate having to copy, paste, reformat or otherwise edit someone's stuff just so they can answer their question.
  * Don't waste too much time on explaining what you did (since that didn't work) - just enough to help your readers understand that you did indeed invest some effort in trying to solve the problem yourself. Spend your time to explain clearly what you want to achieve. Focus on the desired result - not on how to fix your algorithm; your algorithm may be the wrong mental model in the first place.
  * Don't post in HTML, be sure to post in **plain text only**.

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
  * Read ["How to write a reproducible example"](http://adv-r.had.co.nz/Reproducibility.html) and ["How to make a great R reproducible example"](https://stackoverflow.com/questions/5963269/how-to-make-a-great-r-reproducible-example). 
  
  BTW: the same principles apply to questions you post on the course mailing list.
```

## Self-evaluation
 * Question 1
   * Is the apropos() command case-sensitive?
   * Try it out:
      * apropos("^med")
      * apropos("^MED")

## Notes
## Further reading, links and resources
 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-04<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:04-R-help.Rmd-->

# Basics of R syntax {#r-snytax}
(Simple commands and basic syntax, operators, variables, class, mode, and attributes)

## Overview
### Abstract:
This unit discusses simple R commands and basic syntax, operators, and R objects (variables).

### Objectives:

This unit will:

  * introduce basic operations of R syntax;
  * provide examples for use of operators;
  * discuss variable names.

### Outcomes:

After working through this unit you:

  * can evaluate R expressions by typing them on the console;
  * know how to write and debug complex R expressions that are deeply nested with parentheses;
  *  are able to avoid common issues when choosing variable names.

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Console (Console and scripts)](#r-console)
[RPR-Help (Getting help for R)](#r-help)
[RPR-Setup (Setup R to work with it)](#r-setup)
[RPR-Installation (Installing R and RStudio)](#r_install)


## Simple commands

The R command line evaluates expressions. Expressions can contain constants, variables, operators and functions of the various datatypes that R recognizes.


 
### Operators

The common arithmetic operators are recognized in the usual way.

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
  * Open an RStudio session and try the following operators on numbers:
```

```{r, eval=FALSE}
5
5 + 3
5 + 1 / 2 # Think first: is this 3 or 5.5
3 * 2 + 1
3 * (2 + 1)
2^3 # Exponentiation
8 ^ (1/3) # Third root via exponentiation
7 %% 2  # Modulo operation (remainder of integer division)
7 %/% 2 # Integer division

# Logical operators return TRUE or FALSE
#    Unary:
TRUE
FALSE
! TRUE  # read carefully: the "!" (meaning "not") is easily overlooked
! FALSE
 
#    Binary operators
 
1 == 2
1 != 2
1 < 2
1 > 2
 
1 > 1
1 >= 1
1 < 1
1 <= 1
 
#    & (means AND)
TRUE & TRUE
TRUE & FALSE
FALSE & FALSE
 
#    | (means OR)
TRUE | TRUE
TRUE | FALSE
FALSE | FALSE
 
# Predict what this will return
!(FALSE | (! FALSE))
```




Given the expression shown below, the value of lastNum is 9:
```{r, eval=FALSE, echo = TRUE}
numbers <- c(16, 20, 3, 5, 9)
numbers
 
lastNum <- tail(numbers, 1)    # explain what this does
lastNum
 
 
# Note: expressions in parentheses:
# when we assign, e.g. ...
numbers <- sample(1:20, 5)
# ... we can get the value of the vector "numbers" with ...
print(numbers)
# ... or just ...
numbers
 
# But we can also put the entire expression in parentheses, and when it is
# evaluated, which results in the assignment, the value is also printed.
(numbers <- sample(1:20, 5))
# so: when you see parentheses around an entire expression, remember that all
# the parentheses do is to perform some evaluation, and then print the
# resulting object. I use this idiom lot for compactness in teaching code.
# In general, you usually don't need this in scripts that you develop, but for
# teaching I often need you to study the contents of a variable.
```

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Write R expressions:

  1.  To check whether lastNum is less than 6 or greater than 10 ^[lastNum < 6 | lastNum > 10]
  1. To check whether lastNum is in the interval [10, 20). (By the rules of mathematical notation this means 10 is included but 20 is not).^[lastNum >= 10 & lastNum < 20]
  1. To output TRUE if the following operation gives 2^[((((9/7) - ((((9/7) * 10) %/% 1 )/10)) * 100) %/% 1 )^(1/3) == 2]:

    * take lastNum
    * divide it by 7
    * subtract the integer part and the first digit after the decimal point (hint: multiply by 10, then integer division by 1 gives you ... what)
    * multiply by 100
    * integer divide by 1
    * take the third root
(Hints: use lots of parentheses and compare the final result to 2. To debug, select parts of the code and execute separately. If the console gets stuck because it is expecting a closing parenthesis, and all you see is the "+" sign, simply press <escape> to abort evaluation.)
```


 
## Variables

In order to store the results of expressions and computations, you can freely assign them to variables^[We call these "variables" because of what function they perform in our code, they actually are R "objects".]. Variables are created by **R** whenever you first use them (i.e. space in memory is allocated to the variable and a value is stored in that space.) Variable names distinguish between upper case and lower case letters. There are a small number of reserved names that you are not allowed to redefine, and R syntax contains very small number of predefined constants, such as pi. However these constants can be overwritten - be careful: **R** will allow you to define pi <- 3 but casually redefining the foundations of mathematics may lead to unintended consequences. Read more about variable names at:

```{r}
?make.names
?reserved
```

To assign a value to a constant, use the assignment operator <-. This is the default way of assigning values in R. You could also use the = sign, but there are subtle differences. (See: ?"<-"). There is a variant of the assignment operator <<- which is sometimes used inside functions. It assigns to a global context. This is possible, but not preferred since it generates a side effect of a function. Don't do this. Just forget that <<- even exists.

```{r}
a <- 5
a
a + 3
b <- 8
b
a + b
a == b # not assignment: equality test
a != b # not equal
a < b  # less than
```

Note that all of **R**'s data types (as well as functions and other objects) can be assigned to variables.

There are very few syntactic restrictions on variable names ([discussed eg. here](https://stackoverflow.com/questions/9195718/variable-name-restrictions-in-r)) but this does not mean esoteric names are good. For the sake of your sanity, use names that express the meaning of the variable, and that are unique. Many **R** developers use dotted.variable.names, some people use the pothole_style, my personal preference is to write camelCaseNames. And while the single letters c f n s Q are syntactically valid variable names, they coincide with commands for the debugger browser and will execute debugger commands, rather than displaying variable values when you are debugging. Finally, try not to use variable names that are the same as parameter names in functions. Alas, you see this often in code, but such code can be hard to read because the semantics of the actual argument versus the parameter name becomes obscured. It's just common sense really: don't call different things by the same name.

```{r}
# I don't like...
col <- c("red", "grey")
hist(rnorm(200), col=col)
 
# I prefer instead something like...
stripes <- c("red", "grey")
hist(rnorm(200), col=stripes)

```

## Self-evaluation
## Further reading, links and resources
 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-04<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:05-R-basic-syntax.Rmd-->

# R scalars and vectors {#r-scalars}
(Types of R objects: scalars, vectors and matrices)

## Overview
### Abstract:
Introduction to vector objects in R: what are they, how are they created, how can they be subset?

### Objectives:

This unit will:

  * introduce scalars, vectors and matrices;
  * demonstrate vectorized operations;
  * teach various ways of subsetting;

### Outcomes:

After working through this unit you:

  * can create vectors by assignment from sequences or using the c();
  * are familar with subsetting by index, name, and boolean vectors;
  * can subset elements, ranges, and slices from vectors and matrices;
  * can combine objects with c(), rbind(), or cbind().
  
### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Syntax_basics (Basics of R syntax)](#r-syntax)

 
**R** objects can be composed of different kinds of data according to the type and number of "atomic" values they contain:

  * Scalar items are single values;
  * Vectors are ordered sequences of scalars, they must all have the same "data type" (e.g. numeric, logical, character ...);
  * Matrices are vectors for which one or more "dimension(s)" have been defined;
  * "Data frames"" are spreadsheet-like objects, their columns are like vectors and all columns must have the same length, but within one data frame, columns can have different data types. They are the most commonly used type of object to hold data;
  * Lists are the most general collection of data items, the can contain items of any type and kind, including matrices, functions, data frames, and other lists.

 
## Scalar data

Scalars are single numbers, the "atomic" parts of more complex datatypes. Of course we can work with single numbers in R, but under the hood they are actually vectors of length 1. (More on vectors in the next section). To create a scalar object, simply assign some value to its name.

```{r}
x <- pi       # define a scalar by assignment
x             # its value is ...
length(x)     # its length is ...
x[1]          # it is actually a vector, and its first element is ...
x[2]          # a second element does not exist NA: Not Available
```

Here are some remarks on the types of scalars **R** uses, and on coercion between types, i.e. casting one datatype into another. The following scalar types are supported:

  * Boolean constants: TRUE and FALSE. This type has the "mode" logical;
  * Integers, floats (floating point numbers) and complex numbers. These types have the mode numeric;
  * Strings. These have the mode character.
  * Other modes exist, such as list, function and expression, all of which can be combined into complex objects.

The function mode() returns the mode of an object and typeof() returns its type. Also class() tells you what class it belongs to.

```{r}
typeof(TRUE)
class(3L)
mode(print)
```

I have combined these information functions into a single function, objectInfo() which gets loaded and defined when you execute the init() function of the BasicSetup project, so you can explore objects in more detail. We can use objectInfo() to explore how R objects are made up, by handing various expressions as arguments to the function. Many of these you may not yet recognize ... bear with it though:

```{r include=FALSE}
objectInfo <- function(x) {
    # Function to combine various information items about R objects
    #
    # Input: an R object
    # Value: none - prints information as side-effect

    cat("object contents:")
    print(x, digits = 22)  # print value at maximal precision

    cat("\nstructure of object:\n")
    str(x)

    if (! is.list(x)) { # Don't use cat() if x is a list. cat() can't handle lists.
        cat("\nmode:   ", mode(x), "\n")
        cat("typeof: ", typeof(x), "\n")
        cat("class:  ", class(x), "\n")
    }

    # if the object has attributes, print them too
    if (! is.null(attributes(x))) {
        cat("\nattributes:\n")
        attributes(x)
    }
    # Done
}
```

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Load the R-Exercise_BasicSetup project in RStudio if you don't already have it open.
Type init() as instructed after the project has loaded.
Continue below.
```

```{r, eval=FALSE}
#Let's have a brief look at the function itself: typing a function name without its parentheses returns the source code for the function:
objectInfo

# Various objects:
 
#Scalars:
objectInfo( 3.0 )    # Double precision floating point number
objectInfo( 3.0e0 )  # Same value, exponential notation
 
objectInfo( 3 )   # Note: integers are double precision floats by default.
objectInfo( 3L )  # If we really want an integer, we must use R's
                  # special integer notation ...
objectInfo( as.integer(3) )  # or explicitly "coerce" to type integer...
 
# Coercions: For each of these, first think what result you would expect:
objectInfo( as.character(3) )  # Forcing the number to be interpreted as a character.
objectInfo( as.numeric("3") )   # character as numeric
objectInfo( as.numeric("3.141592653") )  # string as numeric. Where do the
                                         # non-zero digits at the end come from?
objectInfo( as.numeric(pi) )    # not a string, but a predefined constant
objectInfo( as.numeric("pi") )  # another string as numeric ... Ooops -
                                # why the warning?
objectInfo( as.complex(1) )
 
objectInfo( as.logical(0) )
objectInfo( as.logical(1) )
objectInfo( as.logical(-1) )
objectInfo( as.logical(pi) )      # any non-zero number is TRUE ...
objectInfo( as.logical("pie") )   # ... but not non-numeric types.
                                  # NA means "Not Available".
objectInfo( as.character(pi) )    # Interesting: the conversion eats digits.
 
objectInfo( Inf )                # Larger than the largest representable number
objectInfo( -Inf )               # ... or smaller
objectInfo( NaN )                # "Not a Number" is numeric
objectInfo( NA )                 # "Not Available" - i.e. missing value is
                                 # logical by default
 
# NULL
objectInfo( NULL )  # NULL is nothing. Not 0, not NaN,
                    # not FALSE - nothing. NULL is the value that is returned
                    # by expressions or functions when the result is
                    # undefined and nothing more can be said about it.
 
objectInfo( as.factor("M") )     # factor
objectInfo( Sys.time() )         # time
objectInfo( letters )            # inbuilt character vector
objectInfo( LETTERS )            # same
objectInfo( 1:4 )                # numeric vector
objectInfo( matrix(1:4, nrow=2)) # numeric matrix
objectInfo( data.frame(arabic = 1:3,                           # data frame
                       roman = c("I", "II", "III"),
                       stringsAsFactors = FALSE))
objectInfo( list(arabic = 1:7,
                 roman = c("I", "II", "III"),
                 chinese = c("一", "二", "三", "四")))   # list
 
# Expressions:
objectInfo( 3 > 5 ) # Note: any combination of two variables via the logical
                    # operators ! == != > < >= <= | || & and && is a
                    # logical expression, and evaluates to TRUE or FALSE.
objectInfo( 3 < 5 )
objectInfo( 1:6 > 4 ) # these are "vectorized" operators
 
objectInfo( a ~ b )              # a formula
objectInfo( objectInfo )         # the function itself

```


Sometimes (but rarely) you may run into a distinction that R makes regarding integers and floating point numbers. By default, if you specify e.g. the number 2 in your code, it is stored as a floating point number. But if the numbers are generated e.g. from a range operator as in 1:2 they are integers! This can give rise to confusion as in the following example:

```{r}
a <- 7
b <- 6:7
str(a)             # num 7
str(b)             # int [1:2] 6 7
a == b[2]          # TRUE
identical(b[2], a) # FALSE ! Not identical! Why?
                   # (see the str() results above.)
```

```{r}
# If you need to be sure that a number is an
# integer, write it with an "L" after the number:
c <- 7L
str(c)             # int 7
identical(b[2], c) # TRUE
```

## Vectors

Since we (almost) never do statistics on scalars, **R** obviously needs ways to handle collections of data items. In its simplest form such a collection is a vector: an ordered list of items of the same type. Vectors are created from scratch with the c() function which concatenates individual items into a vector, or with various sequencing functions. Vectors have properties, such as length; individual items in vectors can be combined in useful ways. It's worth repeating: all elements of a vector must be of the same type. If they are not, they are silently(!) coerced to the most general type (which is often character). (The actual hierarchy for coercion is raw < logical < integer < double < complex < character < list ).

```{r}
# The c() function concatenates elements into a vector
c(2, 4, 6)
```

```{r}
#Create a vector and list its contents and length:
f <- c(1, 1, 3, 5, 8, 13, 21)
f
length(f)
```
 
```{r}
# Often, for teaching code, I want to demonstrate the contents of an object after
# assigning it. I can simply wrap the assignment into parentheses to achieve that.
# Parentheses return the value of whatever they enclose. So ...
a <- 17
# ... assigns 17 to the variable "a". But this happens silently. However ...
( a <- 17 )
# ... returns the result of the assignment. I will use this idiom often.
 
( myVec <- c(1, 1, 3, 5, 8, 13, 21, 34, 55, 89) )
```

```{r}
# Coercion:
# all elements of vectors must be of the same type
(mixed_type <- c(1, 2.0, "3", TRUE))  # trying to get a vector with mixed types ...
class(mixed_type)
```

... shows that all elements are silently being coerced to character. The emphasis is on **silently**. This might be unexpected, for example if you are reading numeric data from a text-file into a vector but someone has entered a " " for a missing value ... then everything is characterified. Nasty.

There are various ways to subset (retrieve) specific values from a vector; this is important.

## Subsetting by index
```{r}
# Extracting by index ...
myVec[1]         # "1" is first element, not 0.
head(myVec, 1)   # same thing
 
myVec[length(myVec)] # length() is the index of the last element.
tail(myVec, 1)       # same thing
 
```


```{r}
# With a vector of indices ...
1:4 # This is the range operator
myVec[1:4] # using the range operator (it generates a sequence and returns it in a vector)
myVec[4:1] # same thing, backwards
seq(from=2, to=6, by=2) # The seq() function is a flexible, generic way to generate sequences
seq(2, 6, 2) # Same thing: arguments in default order
myVec[seq(2, 6, 2)]
```

```{r}
# since a scalar is a vector of length 1, does this work?
5[1]
```

```{r}
# ...using an index vector with positive indices
a <- c(1, 3, 4, 1) # the elements of index vectors must be
                   # valid indices of the target vector.
                   # The index vector can be of any length.
myVec[a] # In this case, four elements are retrieved from f[]
```
 
## Excluding items through negative indexes

Negative indices omit elements:

  * using an index vector with negative indices

```{r}
# If elements of index vectors are negative integers,
# the corresponding elements are excluded.
( a <- -(1:4) ) # Note that this is NOT the same as -1:4
```

```{r}
myVec[a] # Here, the first four elements are omitted from myVec[]
 
myVec[-((length(myVec)-3):length(myVec))] # Here, the last four elements are omitted
```

## Subsetting by boolean vectors

```{r}
myVec > 4         # A logical expression operating on the target vector
                  # returns a vector of logical elements. It has the
                  # same length as the target vector.
myVec[myVec > 4]; # We can use this logical vector to extract only
                  # elements for which the logical expression evaluates as TRUE.
                  # This is also called "filtering".
```

**Note**: the logical vector is aligned with the elements of the original vector. You can't retrieve elements more than once, as you could with index vectors. If the logical vector is shorter than its target it is "recycled" to the full length.

```{r}
(1:20)[c(TRUE, FALSE)]  # odd numbers, but how and why?
```
 
## Subsetting by name

If the vector has named elements, vectors of names can be used exactly like index vectors:
```{r}
summary(myVec)["Median"]
summary(myVec)[c("Max", "Min")]  # Oooops - I mistyped. But you can fix the expression, right?
```


## "[" is an operator

Some more thoughts about "["

  * "[" is not just a special character, it is an operator. 
  * It operates on whatever it is attached to on the left.

```{r}
?"["   # help is available ...
```
 

We have attached "[" to vectors above, but we can also attach it directly to functions or other expressions.

For example, the summary() function returns some basic statistics of a vector:
```{r}
summary(myVec)
```

```{r}
# This is a vector of six numbers:
length(summary(myVec))
```

```{r}
# We can extract e.g. the median like so:
summary(myVec)[3]
```

```{r}
# ... or the boundaries of the interquartile range:
summary(myVec)[c(2, 5)]
```
 
```{r}
# Note that the elements that summary() returns are "named".
# "Names" are attributes.
objectInfo(summary(f))
```

```{r}
# The names() function can retrieve (or set) names:
names(summary(myVec))
```
 
 ... which brings us to yet another way to extract elements from Vectors:

## Subsetting by name:

Extending vectors:

  * Vectors are not immutable. They can grow and shrink as required.
  
```{r}
( x <- 1:3 )
length(x)
x[4] <- 4; x
length(x)
x[7] <- 7; x
length(x)
( x <- x[-(5:6)] )
length(x)
```

 
**Example** : extending the Fibonacci series for three steps.
```{r}
( myVec <- c(myVec, myVec[length(myVec)-1] + myVec[length(myVec)]) )
( myVec <- c(myVec, myVec[length(myVec)-1] + myVec[length(myVec)]) )
( myVec <- c(myVec, myVec[length(myVec)-1] + myVec[length(myVec)]) )
```

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Think: How does this work? What numbers are we adding here and why does the result end up in the vector?
```

 
## Vectorized operations
Many operations on vectors are by default performed for every element of the vector, and **R** computes them **very** efficiently. These are called "vectorized" operations and definitely should be used whenever possible, rather than loops or other explicit iterations.
 
```{r}
myVec
myVec + 1
myVec * 2
log(myVec)
```


 
# computing with two vectors of same length

```{r}
myVec  # the Fibonacci numbers you have defined above
( a <- myVec[-1] )  # like myVec, but omitting the first element
( b <- myVec[1:(length(myVec)-1)] ) # like f, but shortened by the last element
c <- a / b # the "golden ratio", phi (~1.61803 or (1+sqrt(5))/2 ),
           # an irrational number, is approximated by the ratio of
           # two consecutive Fibonacci numbers.

c
abs(c - ((1+sqrt(5))/2)) # Calculating the error of the approximation, element by element
```

```{block, type="rmd-troubleshooting"}
When a number is not a single number:

One of the "warts" of **R** is that some functions substitute a range when they receive a vector of length one. Most everyone agrees this is pretty bad. This behaviour was introduced when someone sometime long ago thought it would be nifty to save two keystrokes. This has caused countless errors, hours of frustration and probably hundreds of undiscovered bugs instead. Today we wouldn't write code like that anymore (I hope), but the community believes that since it's been around for so long, it would probably break more things if it's changed. Two functions to watch out for are sample() and seq(); other functions include diag() and runif().
Consider:
x <- 8; sample(6:x)
x <- 7; sample(6:x)
x <- 6; sample(6:x)  # Oi!
 
# also consider
x <- 6:8; seq(x)
x <- 6:7; seq(x)
x <- 6:6; seq(x)    # Oi vay!
Wherever this misbehaviour is a possibility - i.e. when the number of elements to sample from is variable and could be just one, for example in some simulation code - you can write a replacement function like so...
safeSample <- function(x, size, ...) {
	# Replace the sample() function to ensure sampling from a single
	# value returns that value.
  # Respect additional arguments if present.
    if (length(x) == 1 && is.numeric(x) && x > 0) {
    	if (missing(size)) size <- 1
        return(rep(x, size))
    } else {
        return(sample(x, size, ...))
    }
}

Don't be discouraged though: such warts are rare in R.
```
 
## Matrices and higher-dimensional objects

If we need to operate with several vectors, or multi-dimensional data, we make use of matrices or more generally k-dimensional arrays R. Matrix operations are very similar to vector operations, in fact a matrix actually is a vector for which the number of rows and columns have been defined. Thus matrices inherit the basic limitation of vectors: all elements have to be of the same type.

The most basic way to define matrix rows and columns is to use the dim() function and specify the size of each dimension. Consider:

```{r}
( a <- 1:12 )
```
```{r}
dim(a) <- c(2,6)
a
```

```{r}
dim(a) <- c(4,3)
a
```

```{r}
dim(a) <- c(2,2,3)
a
```

dim() also tells you the number of rows resp. columns a matrix has. For example:

  * dim(a)    # returns the dimensions of a in a vector
  * dim(a)[3]  # only the size of the third dimension of a
  
If you have a two-dimensional matrix, the function nrow() and ncol() will also give you the number of rows and columns, respectively. Obviously, dim(a)[1] is the same as nrow(a).

As an alternative to dim(), matrices can be defined using the matrix() or array() functions (see there), or "glued" together from vectors by rows or columns, using the rbind() or cbind() functions respectively:

```{r}
( a  <- 1:4 )
```
```{r}
( b  <- 5:8 )
```
```{r}
( m1 <- rbind(a, b) )
```
```{r}
( m2 <- cbind(a, b) )
```

```{r}
( m  <- cbind(m2, c = 9:12) )  # naming a column "c" while cbind()'ing it
```


"Subsetting" (retrieving) individual elements or slices from matrices is simply done by specifying the appropriate indices, where a missing index indicates that the entire row or column is to be retrieved.

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Explore how you extract rows or columns from a matrix by specifying them. Within the square brackets the order is [<rows>, <columns<]

  * m[1,] # first row
  * m[, 2] # second column
  * m[3, 2] # element at row == 3, column == 2
  * m[3:4, 1:2] # submatrix: rows 3 to 4 and columns 1 to 2

```

**Note** that **R** has numerous functions to compute with matrices, such as transposition, multiplication, inversion, calculating eigenvalues and eigenvectors and much more.
 
## Self-evaluation
  * Question 1 : Within the square brackets of a matrix the order is [<rows>, <columns>], but what about slices of a 3D matrix? Is it [<slices>, <rows>, <columns>] or [<rows>, <columns>, <slices>]?

  * Answer: Just try - ^[and this means [<rows>, <columns<, <slices>] is correct.]
```{r, eval=FALSE}
x <- 1:27
dim(x) <- c(3, 3, 3)
x
x[2, 1, 1]   # 2
x[1, 1, 2]   # 10
```

## Further reading, links and resources

**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-04<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:06-R-scalars.Rmd-->

# R "data frames"" {#r-data-frames}
(R data frames)

## Overview
### Abstract:
Introduction to data frames: how to create, and modify them and how to retrieve data.

### Objectives:

This unit will:

  * introduce R data frames;
  * cover a number of basic operations.

### Outcomes:

After working through this unit you:

  * know how to create and manipulate data frames;
  * can extract rows, columns, and append new data rows;

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Objects-Vectors (R scalars and vectors)](#r-scalars)


## Data frames

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Load the R-Exercise_BasicSetup project in RStudio if you don't already have it open.
Type init() as instructed after the project has loaded.
Continue below.
```

Data frames are probably the most important type of data object for bioinformatics in **R**; they emulate our mental model of data in a spreadsheet and can be used to implement entity-relationship datamodels.

Usually the result of reading external data from an input file is a data frame. The file below is included with the R-Exercise-BasicSetup project files - it is called plasmidData.tsv, and you can click on it in the Files Pane to open and inspect it.

Name	Size	Marker	Ori	Sites
pUC19	2686	Amp	ColE1	EcoRI, SacI, SmaI, BamHI, XbaI, PstI, HindIII
pBR322	4361	Amp, Tet	ColE1	EcoRI, ClaI, HindIII
pACYC184	4245	Tet, Cam	p15A	ClaI, HindIII

This data set uses tabs as column separators and it has a header line. Similar files can be exported from Excel or other spreadsheet programs. Read this as a data frame as follows:

```{r}

( plasmidData <- read.table(file.path("data_files","plasmidData.tsv"),
                            sep="\t",
                            header=TRUE,
                            stringsAsFactors = FALSE) )
objectInfo(plasmidData)
```

Note the argument stringsAsFactors = FALSE. If this is TRUE instead, **R** will convert all strings in the input to factors and this may lead to problems. Make it a habit to turn this behaviour off, you can always turn a column of strings into factors when you actually mean to have factors.

You can view the data frame contents by clicking on the spreadsheet icon behind its name in the Environment Pane.

## Basic operations

Here are some basic operations with the data frame. Try them and experiment. If you break it by mistake, you can just recreate it by reading the source file again:

```{r}
rownames(plasmidData) <- plasmidData[ , 1]  # use column 1 as rownames
nrow(plasmidData)
ncol(plasmidData)
objectInfo(plasmidData)
```

 
```{r}
x <- plasmidData[2, ]  # assign one row to a variable
objectInfo(x)  # This is also a data frame! One row. It has to be, because
               # it contains elements of type chr and of type int!
 
plasmidData["pBR322", ]  # retrieve one row: different syntax, same thing
 
plasmidData[ , 2]       # retrieve one column
plasmidData[ , "Size"]  # retrieve one column: same principle
```

```{r}
plasmidData <- plasmidData[-2, ]  # remove one row
objectInfo(plasmidData)
 
plasmidData <- rbind(plasmidData, x)  # add it back at the end
objectInfo(plasmidData)
 
```
 
```{r}
# add a new row from scratch:
plasmidData <- rbind(plasmidData, data.frame(Name = "pMAL-p5x",
                                                     Size = 5752,
                                                     Marker = "Amp",
                                                     Ori = "pMB1",
                                                     Sites = "SacI, AvaI, ..., HindIII",
                                                     stringsAsFactors = FALSE))
objectInfo(plasmidData)
```

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
The rowname of the new row of plasmidData is now "1". It should be "pMAL-p5x". Fix this.
```

 

## Self-evaluation

## Further reading, links and resources
 

**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-05<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:07-R-Data-Frames.Rmd-->

# R "Lists" {#r-lists}
(R Lists)

## Overview

### Abstract:

Introduction to R list data types: properties, how to create, and modify them and how to retrieve data.

### Objectives:

This unit will:

  * introduce R lists;
  * cover a number of basic operations.

### Outcomes:

After working through this unit you:

  * know how to create and manipulate lists;
  * can extract items from lists.

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Objects-Data_frames (R "data frames"")](#r-data-frames)

## Lists

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Load the R-Exercise_BasicSetup project in RStudio if you don't already have it open.
Type init() as instructed after the project has loaded.
Continue below.
```

The elements of matrices and arrays all have to be of the same type. Data frames allow us to store elements of different types in columns, but all columns have to have the same length and the elements have to be "atomic" - i.e. you can't put vectors into dataframe columns. But R's lists are much more versatile. They are simply ordered collections of components. These components can have different type - all kinds of R objects can go into a list: characters, booleans, any kind of numeric data, even functions - AND they can have different size.

Lists are created with the list() function, which works similar to the c() function for vectors. Components are accessed through their index in double square brackets, or through their name, using the "$" operator, if the name has been defined. Here is an example:

```{r}
pUC19 <- list(size=2686, marker="ampicillin", ori="ColE1", accession="L01397", BanI=c(235, 408, 550, 1647) )
```

```{r}
objectInfo(pUC19)
```

 
```{r}
pUC19[[1]]
```

```{r}
pUC19[[2]]
```

```{r}
pUC19$ori
```

```{r}
pUC19$BanI[2]
```




**Note** that in we stored multiple restriction enzymes in one string, separated by commas, in our data frame example. While we can take such strings apart again, by using the strsplit() function, the string itself still has to be one single element in the data frame's column. Lists have no such restriction. In our example above, we assigned a vector of restriction site positions to the element "BanI".

You can easily imagine that we could now create a list of lists, and that list of lists could hold an entire plasmid database in a most versatile way. Let's do this!

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}

  * Create a list like with data for pACYC184 following the structure for the pUC19 example but using only size, marker and ori data:

    * size: 4245
    * marker: Tet, Cam
    * ori: p15A

  * Confirm that your new list's structure looks the pUC19 one (minus "accession", and the "BanI"" element).

  * Make a new list, call it plasmidDB and assign to it the puc19 list:
     * plasmidDB <- list()
     * plasmidDB[["pUC19"]] <- pUC19
  * Add your pACYC184 list
  * Add a third element to plasmidDB, "pBR322" using the pBR322 data:
      * size: 4361
      * marker: Amp, Tet
      * ori: ColE1

  * Then: retrieve the entire pACYC184 list
  * Retrieve all sizes from the list. Use unlist() to flatten the result. Then use min() to find the size of the smallest one. [see solution here](http://steipe.biochemistry.utoronto.ca/abc/index.php/RPR-Objects-Lists)

```

Whereas data frames allow you to get all data from a column directly, this is not possible for lists. You need a function that iterates over all list elements instead. Such a function is lapply(), one of several "apply" functions. For example, to get all "ori" elements, try:

```{r}
plasmidDB <- list()
plasmidDB[["pUC19"]] <- pUC19
lapply(plasmidDB, function(x) { return(x$ori) })
```

## Self-evaluation
  * Question 1: Execute: x <- strsplit(plasmidData$Sites, ", ") and analyze the result.

  1. What is plasmidData$Sites?
  1. What is x?
  1. Why does strsplit() have a list as return value, not a vector or a data frame?

## Further reading, links and resources


**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-05<br>
Version: 1.0.2<br>
**Version history**:<br>
1.0.2 Maintenace<br>
1.0.1 Fixed error in list example<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 
 

### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:08-R-Lists.Rmd-->

# Subsetting and filtering R objects {#r-subsetting}
(Subsetting with the [], [[]], and $ operators, filtering)


 
## Overview
### Abstract:
Subsetting and filtering are among the most important operations with data. R provides powerful syntax for these operations. Learn about and practice them in this unit.

### Objectives:

This unit will:

  * introduce subsetting principles;
  * practice them on data;

### Outcomes:

After working through this unit you:

  * can subset and filter data according to six different principles.

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Objects-Lists (R "Lists")](#r-lists)


## Subsetting

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Load the R-Exercise_BasicSetup project in RStudio if you don't already have it open.
Type init() as instructed after the project has loaded.
Continue below.
```

We have encountered "subsetting" before, but we really need to discuss this in more detail. It is one of the most important topics of **R** since it is indispensable to select, transform, and otherwise modify data to prepare it for analysis. You have seen that we use square brackets to indicate individual elements in vectors and matrices. These square brackets are actually "operators", and you can find more information about them in the help pages:

```{r}
?"["     # Note that you need quotation marks around the operator for this.
```


**Note especially:**

  * [ ] "extracts" one or more elements defined within the brackets;
  * [[ ]] "extracts" a single element defined within the brackets;
  * $ "extracts" a single named element.
  * "Elements" are not necessarily scalars, but can apply to a row, column, or more complex data structure. But a "single element" can't be a range, or collection.


```{r include=FALSE}
( plasmidData <- read.table(file.path("data_files","plasmidData.tsv"),
                            sep="\t",
                            header=TRUE,
                            stringsAsFactors = FALSE) )
objectInfo(plasmidData)

```

Here are some examples of subsetting data from the plasmidData data frame we constructed previously. For the most part, this is review:

```{r}
plasmidData[1, ]
```

```{r}
plasmidData[2, ]
```

 
```{r}
# we can extract more than one row by specifying
# the rows we want in a vector ...
plasmidData[c(1, 2), ]
```

```{r}
# ... this works in any order ...
plasmidData[c(3, 1), ]
```
```{r}
# ... and for any number of rows ...
plasmidData[c(1, 2, 1, 2, 1, 2), ]
```
```{r}
# Same for columns
plasmidData[ , 2 ]
```
 
 
```{r}
# We can select rows and columns by name if a name has been defined...
plasmidData[, "Name"]
plasmidData$Name      # different syntax, same thing. This is the syntax I use most frequently.
```

 
```{r}
# Watch this!
plasmidData$Name[plasmidData$Ori != "ColE1"]
# What happened here?
# plasmidData$Ori != "ColE1" is a logical expression, it gives a vector of TRUE/FALSE values
plasmidData$Ori != "ColE1"
```

```{r}
# We insert this vector into the square brackets. R then returns all rows for
# which the vector is TRUE.
 
# In this way we can "filter" for values
plasmidData$Size > 3000
plasmidData$Name[plasmidData$Size > 3000]
```
 
```{r}
# This principle is what we use when we want to "sort" an object
# by some value. The function order() is used to return values
# that are sorted. Remember this: not sort() but order().
order(plasmidData$Size)
plasmidData[order(plasmidData$Size), ]
```
 
```{r}
# grep() matches substrings in strings and returns a vector of indices
grep("Tet", plasmidData$Marker)
plasmidData[grep("Tet", plasmidData$Marker), ]
plasmidData[grep("Tet", plasmidData$Marker), "Ori"]

```

Elements that can be extracted from an object also can be replaced. Simply assign the new value to the element.
 
```{r}
( x <- sample(1:10) )
x[4] <- 99
x
( x <- x[order(x)] )
```

Try your own subsetting ideas. Play with this. I find that even seasoned investigators have problems with subsetting their data and if you become comfortable with the many ways of subsetting, you will be ahead of the game right away.

`r task_counter <- task_counter + 1`
## Task `r task_counter`
 
```{block, type="rmd-task"}
  * The R-Exercise_BasicSetup project contains a file subsettingPractice.R
  * Open the file and work through it.
```

## Self-evaluation

## Further reading, links and resources

**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-05<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenace<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:09-R-Subsetting.Rmd-->

# Control structures of R {#r-control-structures}
(if, else if, ifelse, for, and while; vectorized commands as alternatives)

## Overview
### Abstract:
Introducing control structures: if, else if, ifelse, for, and while.

### Objectives:

This unit will:

  * introduce the main control structures of R;

### Outcomes:

After working through this unit you:

  * can read, analyze and write conditional expressions using if, else, and the ifelse() function;
  * can read, analyze and write for loops using the range operator and the seq_along() function;
  * can construct while loops with a termination condition.
  
### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Subsetting (Subsetting and filtering R objects)](#r-subsetting)


```{block type="rmd-caution"}
This page is tagged for revision; expect changes and proceed with caution.
``` 

## Control structures

"Control structures" are parts of the syntax that execute code according to whether some condition is met. Let's look at this with some simple examples:


 
### if and else

```{r, eval=FALSE}
# Code pattern
if (<conditional expression evaluates to TRUE>) {
    <execute this block>
} else if (<expression evaluates to TRUE>) {
    <execute this block>
} else {
    <execute this block>
}
```

 
### conditional expressions
  * anything that evaluates to TRUE or FALSE, or can be coerced to a logical.
  * Obviously the operators:
  
    * ! - not equals
    * == - equals
    * < - less than
    * > - greater than
    * <= - less than or equal
    * >= - greater than or equal
    
  *  but there are also a number of in-built functions that are useful for this purpose:
  
    * all - are all values in the set TRUE
    * any - are any of the values in the set TRUE
    * exists - does the object exist
    * is.character - is the object of type character
    * is.factor - is the object of type factor
    * is.integer - is the object of type integer
    * is.null - - is the object null
    * is.numeric - is the object of type numeric
    * is.unsorted - is the object sorted
    * is.vector - is the object of type vector

  * Simple "if" statement:
    * Rolling a die. If you get a "six", you get to roll again.
 
```{r}
x <- sample(1:6, 1)
if (x == 6) {
    x <- c(x, sample(1:6, 1))
}
print(x)
```

 
### "if", "else if", and "else"

Here is a popular dice game called high-low.
 
```{r}
a <-  sample(1:6, 1)
b <-  sample(1:6, 1)
if (a + b > 7) {
    print("high")
} else if (a + b < 7) {
    print("low")
} else {
    print("seven")
}
```

We need to talk about conditional expressions that test for more than one condition for a moment, things like: "if this is true OR that is true OR my birthday is a Sunday this year ...". To join logical expressions, R has two distinct sets of operators: 

  * | and ||, 
  * and & and &&. 
  
  **| is for "or" and & is for "and". But what about && and ||?** 
  
  The single operators are "vectorized" whereas the doubled operators short-circuit. 
  
  This means if you apply the single operators to a vector, you get a vector of results:
```{r}
x <- c(1, 3, 5, 7, 11, 13, 17)
x > 3 &  x < 17 # FALSE FALSE  TRUE  TRUE  TRUE  TRUE FALSE: all comparisons
x [x > 3 &  x < 17]  #  5  7 11 13
 
x > 3 && x < 17 # FALSE: stop at the first FALSE
```

The vectorized version is usually what you want, e.g. for subsetting, as above. But it is usually not the right way in control structures: there, you usually want never to evaluate unnecessary expressions. Chained "OR" expressions can be aborted after the first TRUE is encountered, and chained "AND" expressions can be aborted after the first FALSE. Which is what the double operators do.

```{r}
x <- numeric()

if (length(x) == 0 || is.na(x)) { print("zero") }  # no error: length test is TRUE so is.na()
                                                   # never gets evaluated.
```

```{r, eval = FALSE}
 
if (length(x) == 0 |  is.na(x)) { print("zero") }  # throws an error, because is.na() is
                                                   # evaluated even though x has length zero.
```

**Bottom line: always use || and && in control structures.**

### ifelse
The ifelse() function deserves special mention: its arguments work like an if / else construct ...

ifelse(5 > 7, TRUE, FALSE)
 
```{r}
ifelse(runif(1) > 0.5, "pickles", "cucumbers")
```

i.e. ifelse(<condition is true>, <evaluate this>, <evaluate that> )

But the cool thing about ifelse() is that it's vectorized! You can apply it to a whole vector of conditions at once:

```{r}
set.seed(27);        runif(10)
```

```{r}
set.seed(27);        runif(10) > 0.2
```

```{r}
set.seed(27); ifelse(runif(10) > 0.2, "caution", " to the wind")
``` 

```{r}
set.seed(NULL)
```


 
### for

"for" loops are the workhorse of innumerable R scripts. They are controlled by a sequence, and a variable. The body of the loop is executed once for each element in the sequence. Most often, the sequence is a sequence of integers, created with the colon - the range operator. The pattern is:

for (<element> in <vector>) {
   <expressions using element...>
}

```{r}
# simple for loop
for (i in 1:10) {
	print(c(i, i^2, i^3))
}
```

 Let's stay with the high-low game for a moment:
  * What are the odds of winning?
  * Let's simulate some runs with a "for" loop.
 
```{r}
N <- 25000
outcomes <- character(N)  # initialize an empty vector
for (i in 1:N) {          # repeat, assign each element of 1:N to
                          # the variable "i" in turn
    a <-  sample(1:6, 1)
    b <-  sample(1:6, 1)
    if (a + b > 7) {
        outcomes[i] <- "high"
    } else if  (a + b < 7) {
        outcomes[i] <- "low"
    } else {
        outcomes[i] <- "seven"
    }
}
head(outcomes, 36)
table(outcomes)  # the table() function tabulates the elements
                 # of a vector
```

 
round((36 * table(outcomes))/N) # Can you explain this expression?

Note that there is nothing special about the expression for (i in 1:N) { ... . Any expression that generates a sequence of items will do; I write a lot of code like for (fileName in dir()) { ... or for (gene in data$name) {... , or for (column in colnames(expressionTable)) {... etc.

Loops in **R** can be slow if you are not careful how you write them. The reason is usually related to dynamically managing memory. If you can, you should always pre-define objects of sufficient size to hold your results. Even better, use a vectorized approach.

### Compare excution times: one million square roots from a vector of random numbers ...
 
```{r}
# Version 1: Naive for-loop: grow result object as required
N <- 1000000                 # Set N to a large number
x <- runif(N)                # get N uniformily distributed random numbers
y <- numeric()               # create a variable to assign to
startTime <- Sys.time()      # save start time
for (i in 1:N) {             # loop N-times
  y[i] <- sqrt(x[i])         # calculate one square root, grow y to store it
}
Sys.time() - startTime       # time it took
rm(x)                        # clean up
rm(y)
```

```{r}
# Version 2: Define result object to be large enough
N <- 1000000                 # Set N to a large number
x <- runif(N)                # get N uniformily distributed random numbers
y <- numeric(N)              # create a variable with N slots
startTime <- Sys.time()      # save start time
for (i in 1:N) {             # loop N-times
  y[i] <- sqrt(x[i])         # calculate one square root, store in Y
}
Sys.time() - startTime       # time it took
rm(x)                        # clean up
rm(y)
```
 
```{r}
# Version 3: vectorized
N <- 1000000                 # Set N to a large number
x <- runif(N)                # get N uniformily distributed random numbers
startTime <- Sys.time()      # save start time
y <- sqrt(x)                 # sqrt() is vectorized!
Sys.time() - startTime       # time it took
rm(x)                        # clean up
rm(y)
```

 
** The tiny change of pre-allocating memory for the result object y, rather than dynamically growing the vector has made a huge difference. But using the vectorized version of the sqrt() function directly is the fastest approach.**

 
### seq_along() vs. range

Consider the following carefully:

Assume we write a loop to iterate over vectors of variable length for example going from e to pi with a given number of elements:
```{r}
( v5 <- seq(exp(1), pi, length.out = 5) )
```
```{r}
( v2 <- seq(exp(1), pi, length.out = 2) )
```
```{r}
( v1 <- seq(exp(1), pi, length.out = 1) )
```


```{r}
( v0 <- seq(exp(1), pi, length.out = 0) )
```

The idiom we will probably find most commonly for this task is uses the range operator ":" 
```{r}
1:length(v5)
1:length(v2)
```

```{r}
for (i in 1:length(v5)) {
  print(v5[i])
}
```

```{r}
for (i in 1:length(v2)) {
  print(v2[i])
}
```

```{r}
for (i in 1:length(v1)) {
  print(v1[i])
}
```
 

```{r}
for (i in 1:length(v0)) {
  print(v0[i])
}
```


The problem with the last iteration is: we probably didn't want to execute the loop if the vector has length 0. But since 1:length(v0) is the same as  1:0, we get an erroneous execution.
 
This is why we should always use the following idiom instead, when iterating over a vector: the function seq_along().

** seq_along() builds a vector of indices over its argument.**

```{r}
seq_along(v5)
```

```{r}
seq_along(v2)
```

```{r}
seq_along(v1)
```

```{r}
seq_along(v0)
```

```{r}
for (i in seq_along(v5)) {
  print(v5[i])
}
```

```{r}
for (i in seq_along(v2)) {
  print(v2[i])
}
```

```{r}
for (i in seq_along(v1)) {
  print(v1[i])
}
```

```{r}
for (i in seq_along(v0)) {
  print(v0[i])
}
```
 
Now we get the expected behaviour: no output if the vector is empty.

 
### loops vs. vectorized expressions

If you can achieve your result with an R vector expression, it will be faster than using a loop. But sometimes you need to do things explicitly, for example if you need to access intermediate results.

Here is an example to play some more with loops: a password generator. Passwords are a pain. We need them everywhere, they are frustrating to type, to remember and since the cracking programs are getting smarter they become more and more likely to be broken. Here is a simple password generator that creates random strings with consonant/vowel alterations. These are melodic and easy to memorize, but actually as strong as an 8-character, fully random password that uses all characters of the keyboard such as )He.{2jJ or #h$bB2X^ (which is pretty much unmemorizable). The former is taken from 207 * 77 1015 possibilities, the latter is from 948 ~ 6*1015 possibilities. High-end GPU supported password crackers can test about 109 passwords a second, the passwords generated by this little algorithm would thus take on the order of 106 seconds or eleven days to crack^[That's assuming the worst case in that the attacker needs to know the pattern with which the password is formed, i.e. the number of characters and the alphabet that we chose from. But note that there is an even worse case: if the attacker had access to our code and the seed to our random number generator. If you start the random number generator e.g. with a new seed that is generated from Sys.time(), the possible space of seeds can be devastatingly small. But even if a seed is set explicitly with the set.seed(<number>) function, the <number> seed is a 32-bit integer (check this with .Machine$integer.max) and thus can take only a bit more than 4*109 values, six orders of magnitude less than the 1015 password complexity we thought we had! It turns out that the code may be a much greater vulnerability than the password itself. Keep that in mind. Keep it secret. Keep it safe.]. This is probably good enough to deter a casual attack.

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Copy, study and run the below code
```

```{r, eval = FALSE}
# Suggest memorizable passwords
# Below we use the functions:
?nchar
?sample
?substr
?paste
?print
 
#define a string of  consonants ...
con <- "bcdfghjklmnpqrstvwxz"
# ... and a string of of vowels
vow <- "aeiouy"
 
for (i in 1:10) {  # ten sample passwords to choose from ...
    pass = rep("", 14)  # make an empty character vector
    for (j in 1:7) {    # seven consonant/vowel pairs to be created ...
        k   <- sample(1:nchar(con), 1)  # pick a random index for consonants ...
        ch  <- substr(con,k,k)          # ... get the corresponding character ...
        idx <- (2*j)-1                  # ... compute the position (index) of where to put the consonant ...
        pass[idx] <- ch                 # ...  and put it in the right spot
 
        # same thing for the vowel, but coded with fewer intermediate assignments
        # of results to variables
        k <- sample(1:nchar(vow), 1)
        pass[(2*j)] <- substr(vow,k,k)
    }
    print( paste(pass, collapse="") )  # collapse the vector in to a string and print
}
```

** Try this a few times.**

### while

Whereas a for-loop runs for a fixed number of times, a "while" loop runs as long as a condition is true, possibly forever. Here is an example, again our high-low game: this time we simulate what happens when we play it more than once with a strategy that compensates us for losing.

Let's assume we are playing high-low in a casino. You can bet high or low. You get two dollars for one if you win, nothing if you lose. If you bet "high", you lose if we roll "low" or "seven". Thus your chances of winning are 15/36 = 42%. You play the following strategy: start with 33 dollars. Bet one dollar. If you win, good. If you loose, triple your bet. Stop the game when your funds are gone (bad), or if you have more than 100 dollars (good) - i.e. you have tripled the funds you risked. Also stop if you've played more than 100 rounds and start getting bored.
 
```{r}
funds <- 33
bet <- 1         # our first bet
 
nPlays <- 0      # this counts how often we've played
MAXPLAYS <- 100
 
set.seed(1234567)
while (funds > 0 && funds < 100 && nPlays < MAXPLAYS) {
 
    bet <- min(bet, funds)  # can't bet more than we have.
    funds <- funds - bet    # place the bet
    a <-  sample(1:6, 1)    # roll the dice
    b <-  sample(1:6, 1)
 
    # we always play "high"
    if (a + b > 7) {        # we win :-)
        result <- "Win!  "
        funds <- funds + (2 * bet)
        bet <- 1            # reset the bet to one dollar
    } else {                # we lose :-(
        result <- "Lose."
        bet <- 3 * bet      # increase the bet to 3 times previous
    }
    print(paste("Round", nPlays, result,
                "Funds now:", funds,
                "Next bet:", bet))
    nPlays <- nPlays + 1
}
set.seed(NULL)
```
 
**Now before you get carried away - try this with different seeds and you'll quickly figure out that the odds of beating the game are not all that great...**

`r task_counter <- task_counter + 1`
## Task `r task_counter` 

```{block, type="rmd-task"}
A rocket ship has to sequence a countdown for the rocket to launch. You are starting the countdown from 3. You want to print the value of variable named txt that outputs:

[1]  "3"          "2"          "1"          "0"          "Lift Off!"
Using what you learned above, write a while loop that gives the output above.


Sample Solution:

start <- 3
txt <- as.character(start)
countdown <- start
while (countdown > 0) {
  countdown <- countdown - 1
  txt <- c(txt, countdown)
}
txt <- c(txt, "Lift Off!")
txt
```

 
## Self-evaluation
## Further reading, links and resources

**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2019-01-07<br>
Version: 1.1<br>
**Version history**:<br>
1.0 Udate set.seed() usage<br>
1.0.1 Maintenance; clarify for-loop comparison<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:10-R-control-structures.Rmd-->

# R Functions {#r-functions}
(Anatomy of a function: arguments, parameters and values; the concept of functional programming.)


 
## Overview
### Abstract:
In this unit we discuss the "anatomy"" of R functions: arguments, parameters and values, and how R's treatment of functions supports "functional programming".

### Objectives:

This unit will:

  * introduce the basic pattern of R functions;
  * discuss arguments and parameters;
  * show how to retrieve the source code from within a function;
  * practice writing your own functions.

### Outcomes:

After working through this unit you:

  * know how to pass parameters into functions and assign the returned values;
  * can read, analyze, and write your own functions.

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Control_structures (Control structures of R)](#r-control-structures)
 
## Functions

**R** is considered an (impure) functional programming language and thus the focus of R programs is on functions. The key advantage is that this encourages programming without side-effects and this makes it easier to write error free code and maintain it. Function parameters^[The terms parameter and argument have similar but distinct meanings. A parameter is an item that appears in the function definition, an argument is the actual value that is passed into the function.] are instantiated for use inside a function as the function's arguments, and a single result is returned[However a function may have side-effects, such as writing something to console, plotting graphics, saving data to a file, or changing the value of variables outside the function scope. But changing values outside the scope is poor practice, always to be avoided.]. The return values can either be assigned to a variable, or used directly as the argument of another function. This means functions can be nested, and intermediate assignment is not required.

Functions are either built-in (i.e. available in the basic **R** installation), loaded via specific packages, or they can be easily defined by you (see below). In general a function is invoked through its name, followed by one or more arguments in parentheses, separated by commas. Whenever I refer to a function, I write the parentheses to identify it as such and not a constant or other keyword eg. log(). Here are some examples for you to try and play with:

```{r}
cos(pi) #"pi" is a predefined constant.
```
```{r}
sin(pi) # Note the rounding error. This number is not really different from zero.
```
```{r}
sin(30 * pi/180) # Trigonometric functions use radians as their argument - this conversion calculates sin(30 degrees)
```
```{r}
exp(1) # "e" is not predefined, but easy to calculate.
```
```{r}
log(exp(1)) # functions can be arguments to functions - nested functions are evaluated from the inside out.
```
```{r}
log(10000) / log(10) # log() calculates natural logarithms; convert to any base by dividing by the log of the base. Here: log to base 10.
```
```{r}
exp(complex(r=0, i=pi)) #Euler's identity
```

There are several ways to populate the argument list for a function and **R** makes a reasonable guess what you want to do. Arguments can either be used in their predefined order, or assigned via an argument name. Let's look at the complex() function to illustrate this. Consider the specification of a complex number in Euler's identity above. The function complex() can work with a number of arguments that are explained in the documentation (see: ?complex). Its signature includes length.out, real, imaginary, and some more.

```{r}
complex(length.out = 0, real = numeric(), imaginary = numeric(), modulus = 1, argument = 0)
```

The length.out argument creates a vector with one or more complex numbers. If nothing else is specified, this will be a vector of complex zero(s). If there are two, or three arguments, they will be placed in the respective slots. However, since the arguments are named, we can also define which slot of the argument list they should populate.


Consider the following to illustrate this:
```{r}
complex(1)    # parameter is in the first slot -> length.out
```

```{r}
complex(4)
```
```{r}
complex(1, 2) # imaginary part missing
```
```{r}
complex(1, 2, 3) # one complex number with real and imaginary parts defined
```
```{r}
complex(4, 2, 3) # four complex numbers
```

```{r}
complex(real = 0, imaginary = pi) # defining values via named parameters
```
```{r}
complex(imaginary = pi, real = 0) # same thing - if names are used, order is not important
```
```{r}
complex(re = 0, im = pi) # names can be abbreviated ...
```
```{r}
complex(r = 0, i = pi)   # ... to the shortest string that is unique among the named parameters,
                         # but this is _poor_ practice, strongly advises against.
```
```{r}
complex(i = pi, 1, 0) # Think: what have I done here? Why does this work?
```
```{r}
exp(complex(i = pi, 1, 0)) # (The complex number above is the same as in Euler's identity.)
```

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
A frequently used function is seq().

  1. Read the help page about seq()
  1. Use seq() to generate a sequence of integers from -5 to 3. Pass arguments in default order, don't use argument names.
  1. Use seq() to generate a sequence of numbers from -2 to 2 in intervals of 1/3. This time, use argument names.
  1. Use seq() to generate a sequence of 30 numbers between 1 and 100. Pass the arguments in the following order: length.out, to, from.
```
 
## On missing parameters

If a parameter is missing several things can happen. Let's illustrate wih a little function that returns the golden-ratio pair to a number, either the smaller, or the larger one.

```{r}
goldenRatio <- function(x, smaller) {
  phi <- (1 + sqrt(5)) / 2
  if (smaller == TRUE) {
    return(x / phi)
  } else {
    return(x * phi)
  }
}
```

If there's no way to recover, executing the function will throw an error:

```{r,eval=FALSE}
goldenRatio(1)
```

Error in goldenRatio(1) : argument "smaller" is missing, with no default

If the function has a default parameter defined, it is used :

```{r}
goldenRatio <- function(x, smaller = TRUE) {
  phi <- (1 + sqrt(5)) / 2
  if (smaller == TRUE) {
    return(x / phi)
  } else {
    return(x * phi)
  }
}
```


```{r}
goldenRatio(1)
```
 
Alternatively, the function body can check whether a parameter is missing with the missing() function, and then react accordingly:

```{r}
goldenRatio <- function(x, smaller) {
  if (missing(smaller)) {
    smaller <- TRUE
  }
  phi <- (1 + sqrt(5)) / 2
  if (smaller == TRUE) {
    return(x / phi)
  } else {
    return(x * phi)
  }
}
```

```{r}
goldenRatio(1)
```

```{r}
goldenRatio(1, smaller = FALSE)
```


Why is this useful, if you could just define a default? Because the parameter can then be the result of a (complex) computation, based on other parameters.


 
## Reading functions
 
### Basic R
If the function is a normal R function, like the ones we have defined above, you can read the function code when type its name without parantheses:

```{r}
goldenRatio
```

But that strictly only works for functions which have been written in basic R code.


### S3 methods

You might also get a line saying UseMethod(<function name>). Then you are looking at a "method" from R's S3 object oriented system - such a function is also called a "generic", because it dispatches to more specific code, depending on the type of the parameter it is being given. Use methods() to see which specific methods are defined, and then use getAnywhere(<function.class>) to get the code.

```{r}
seq
```

```{r}
methods(seq)
```

```{r}
getAnywhere(seq.default)
```

## Primitives

You might also get a line saying .Call(C_<function name> <arguments>). Then you are looking at a primitive - a function that has been compiled in the C programming language, for efficiency.

```{r}
runif
```
 

To read the C source code, just do a Google search for the function name in the repository where the R sources are kept:

This search finds runif.c (have a look).[site:https://svn.r-project.org/R/trunk/src runif](https://www.google.com/search?q=site%3Ahttps%3A%2F%2Fsvn.r-project.org%2FR%2Ftrunk%2Fsrc+runif&rlz=1C5CHFA_enCA740CA742&oq=site%3Ahttps%3A%2F%2Fsvn.r-project.org%2FR%2Ftrunk%2Fsrc+runif&aqs=chrome..69i57j69i58.3647j0j4&sourceid=chrome&ie=UTF-8)


 
## Writing your own functions

**R** is a "functional programming language" and working with **R** will involve writing your own functions. This is easy and gives you access to flexible, powerful and reusable solutions. You have to understand the "anatomy" of an R function however.

Functions are assigned to function names. They are treated like any other R object and you can have vectors of functions, and functions that return functions etc.
Data gets into the function via the function's parameters.

Data is returned from a function via the return() statement[Actually the return() statement is optional, if missing, the result of the last expression is returned. You will find this frequently in other people's code, somthing to be aware of. However, you'll surely understand that it is really poor practice to omit return(), it makes the code harder to read and can give rise to misunderstandings. Never use implicit behaviour where you can be explicit instead]. One and only one object is returned. However the object can be a list, and thus contain values of arbitrary complexity. This is called the "value" of the function. 
Well-written functions have no side-effects like changing global variables.

```{r,eval=FALSE}
# the function definition pattern:
 
<myName> <- function(<myArguments>) {
  # <documentation!>
	result <- <do something with the parameters>
	return(result)
}
```

In this pattern, the function is assigned to the name - any valid name in **R**. Once it is assigned, it the function can be invoked with myName(). The parameter list (the values we write into the parentheses following the function name) can be empty, or hold a list of variable names. If variable names are present, you need to enter the corresponding parameters when you execute the function. These assigned variables are available inside the function, and can be used for computations. This is called "passing variables into the function".

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
This exercise is similar to the while loop exercise. The only difference is to put the code into a function. Write a function countDown() so that you can start the countdown call from any number. For example calling countDown(5) should give:

[1]  "5"          "4"          "3"          "2"          "1"          "0"          "Lift Off!"

```

Answer^[countDown <- function(n) {<br>start <- n<br>  countdown <- start<br>  txt <- as.character(start)<br>  <br>  while (countdown > 0) {<br>    countdown <- countdown - 1<br>    txt <- c(txt, countdown)<br>  }<br>  txt <- c(txt,"Lift Off!")<br>  return(txt)<br>}<br> <br>countDown(7)<br>]
 
The scope of functions is local: this means all variables within a function are lost upon return, and global variables are not overwritten by a definition within a function. However variables that are defined outside the function are also available inside.

We can use loops and control structures inside functions. For example the following creates a vector containing n Fibonacci numbers.

```{r}
fibSeq <- function(n) {
   if (n < 1) { return( 0 ) }
   else if (n == 1) { return( 1 ) }
   else if (n == 2) { return( c(1, 1) ) }
   else {
      v <- numeric(n)
      v[1] <- 1
      v[2] <- 1
      for ( i in 3:n ) {
         v[n] <- v[n-2] + v[n-1]
      }
      return( v )
   }
}

```

 
Here is another example to play with: a function that calculates how old you are. In days. This is neat - you can celebrate your 10,000 birthday - or so.

`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Copy, explore and run the below code
```

Define the function ...
```{r}
# A lifedays calculator function
 
myLifeDays <- function(birthday) {
  if (missing(birthday)) {
    print ("Enter your birthday as a string in \"YYYY-MM-DD\" format.")
    return()
  }
  bd <- strptime(birthday, "%Y-%m-%d") # convert string to time
  now <- format(Sys.time(), "%Y-%m-%d") # convert "now" to time
  diff <- round(as.numeric(difftime(now, bd, unit="days")))
  print(sprintf("This date was %d days ago.", diff))
}
```

Use the function (example)
```{r}
   myLifeDays("1932-09-25")  # Glenn Gould's birthday
```


Here is a good opportunity to practice programming: modify this function to accept a second argument. When a second argument is present (e.g. 10000) the function should print the calendar date on which the input date will be the required number of days ago. Then you could use it to know when to celebrate your 10,000th life-day, or your 777th anniversary or whatever.


 

## Self-evaluation

## Further reading, links and resources
["How can I view the source code for a function?" (On Stack Overflow)](https://stackoverflow.com/questions/19226816/how-can-i-view-the-source-code-for-a-function)

 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2019-01-07<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:11-R-Functions.Rmd-->

# Introduction to R Plots {#r-plots}

(Introduction to R plots)

## Overview
### Abstract:
Introductory concepts and exercises for creating graphics with R.

### Objectives:

This unit will:

  * introduce concepts of graphics for data visualization and descrptive statistics;
  * teach basic plotting methods;

### Outcomes:

After working through this unit you:

  * know where to find models of good data visualization;
  * can create and customize basic plots in R;
  
### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Functions (R Functions)](#r-functions)
 
`r task_counter <- task_counter + 1`
## Task `r task_counter`

```{block, type="rmd-task"}
Read the introductory notes on [graphics in R](boris_docs/RPR-Plotting.pdf), and some concepts of graphics for descriptive statistics.
Load the R-Exercise_BasicSetup project in RStudio if you don't already have it open.
Type init() as instructed after the project has loaded.
Work through the plottingIntro.R script.
```

## Types of plots

This lists the generic plots only. Many more specialized plot-types are available.

  * plot()
  * pie()
  * hist()
  * stripchart()
  * stem()
  * barplot()
  * boxplot()


### plot() 
```{r}
?plot
```


```{r}
# generate some data to plot
x <- rnorm(200)
y <- x^3 * 0.25 + rnorm(200, 0, 0.75)

?plot
# standard scatterplot
plot(x,y)
```


```{r}

plot(x,y)

# Add a rug representation:
rug(x)
rug(y, side=2, col="red")
```




### barplot()  

```{r}
?barplot
barplot(table(round(y)))
```




###  hist() 
```{r}
?hist
set.seed(12357)
x <- rnorm(50)
hist(x, breaks=5)
```


```{r}
hist(x, breaks=5)
# add a stripchart() of the actual values
stripchart(x, pch="|", add=TRUE, col="red3", xlim=c(-3, 3), at=-0.5)
```


**Note:** a similar plot for bivarite data is achieved with the rug() function.

assigning the output of hist() makes the values used in constructing the histogram accessible:

```{r}
info <- hist(x, breaks=5)
info
```


we can explicitly set breakpoints in a vector:
  * here we set them at 0.5 sigma intervals from -3 to 3

```{r}
s <- 1.0
hist(x, breaks=seq(-3*s, 3*s, by=0.5*s))
```

```{r}
# we can colour the bars individually...
hcol <- c("#4F47FD", "#6982FC", "#8AA6EF", "#AFBBDB", "#BEBEBE", "#A9A9A9",
          "#A9A9A9", "#BEBEBE", "#DBBBAF", "#EFA68A", "#FC8269", "#FD474F")

# Most parameters of a generic plot apply.
h <- hist(x, breaks=seq(-3*s, 3*s, by=0.5*s),
          col=hcol,
          main="",
          xlab=expression(sigma),
          ylab="Counts")

# ... and we can add the individual counts to the plot.
text(h$mids, h$counts, h$counts, adj = c(0.5, -0.5), col = hcol)

```



### boxplot

```{r}
?boxplot
x <- rnorm(200)
boxplot(x)

```

```{r}
m <- x
m <- cbind(m, x^2)
m <- cbind(m, x^3)
m <- cbind(m, x^4)
m <- cbind(m, x^5)
boxplot(m)

```

```{r}
boxplot(log(abs(m)))
```



###   Colour  

Colours can be specified by number, by name, as hex-triplets as rgb or hsv values, and through colour palettes.

####  Colours by number  
The col=... parameter for plots is 1 by default and you can set it to the range 0:8.

  * 0: white
  * 1: black (the default)
  * 2: red
  * 3: green
  * 4: blue
  * 5: cyan
  * 6: magenta
  * 7: yellow
  * 8: grey

```{r}
barplot(rep(1,9), col=0:8, axes=FALSE, names.arg=c(0:8))
```
  
As you can see, these primary colours are decidedly garish and offend even the most rudimentary sense of aesthetics. Fortunately there are much more sophisticated ways to define colours in R.

#### 2.2  Colours by name 
You may have noticed that "red", "green", and "blue" work for the col=... parameter, but you probably would not have imagined that "peachpuff", "firebrick" and "goldenrod" are valid as well. In fact, there are 657 named colours in R. Access them all by typing:

```{r}
colors()
```

```{r}
pie(c(1, 1, 2, 3, 5, 8, 13),
    col=c(
    "firebrick2",
    "tomato",
    "goldenrod1",
    "peachpuff",
    "papayawhip",
    "seashell",
    "whitesmoke"
    )
    )
```


Read more about named colours (and related topics) [here](http://research.stowers.org/mcm/efg/R/Color/Chart/)

####  Colours as hex-triplets 

Hex triplets in **R** work exactly as in HTML: a triplet of RGB values in two-digit hexadecimal representation. The first two digits specify the red value, the second two are for green, then blue. R accepts a fourth pair of digits to optionally specify the transparency, the semantics of the code is thus "#RRGGBB" or "#RRGGBBAA". Read more e.g. at http://en.wikipedia.org/wiki/Web_colors

```{r}
# The function col2rgb() converts colour names to rgb values ...
col2rgb("violetred")
```

```{r}
# ... and rgb() converts rgb values to hex-code:
rgb(1, 0.5, 0.23)
```


Unfortunately the output of col2rgb does not quite match rgb(). col2rgb creates rows with values between 0 and 255, and rgb by default expects columns with intensities from 0 to 1, you have to transpose and divide.

```{r}
rgb(t(col2rgb("red"))/255)        # "#FF0000"
rgb(t(col2rgb("peachpuff"))/255)  # "#FFDAB9"
```


There are many tools on the Web that help to generate pleasing palettes.

Here is an example -"Creative Cloud"- taken from  https://kuler.adobe.com/

```{r}
CC <- c("#011640", "#024059", "#F2F0D0", "#BE6C5C", "#8C3037" )
hist(rnorm(1000), breaks=20 , col=CC)
```

R colours are actually specified as quartets: the fourth value the "Alpha channel" defines the transparency. Setting this to values other than "FF" (the default) can be useful for very crowded plots, or for creating overlays.

```{r}
x <- rnorm(2000)
y <- x^3 * 0.25 + rnorm(2000, 0, 0.75)

```

compare:

```{r}
plot(x,y, pch = 19, col = "#EE3A8C")

```

And
```{r}
plot(x,y, pch = 19, col = "#EE3A8C12") # Alpha at ~ 10%
```


or with multiple overlays of varying size using points() ...
```{r}
plot(  x,y, pch = 16, cex = 1,   col = "#AA330009")
```

```{r}
plot(x,y, pch = 19, cex = 2,   col = "#44558803")
```

```{r}
plot(x,y, pch = 20, cex = 0.5, col = "#EE3A8C08")
```

A similar behaviour can be obtained from "density adapted colors with the densCols() function

```{r}
plot (x, y, col = densCols(x, y), pch = 19, cex = 1.5)
```




### Colour palettes  

R has several inbuilt colour palettes, or you can build your own.
```{r}
# Inbuilt palettes
?rainbow
```


  * view the palettes
```{r}
opar <- par(mfrow=c(3,2))
n <- 20
sq <- rep(1, n)
barplot(sq, col=rainbow(n),        axes=F, main="rainbow(n)")
barplot(sq, col=cm.colors(n),      axes=F, main="cm.colors(n)")
barplot(sq, col=topo.colors(n),    axes=F, main="topo.colors(n)")
barplot(sq, col=terrain.colors(n), axes=F, main="terrain.colors(n)")
barplot(sq, col=heat.colors(n),    axes=F, main="heat.colors(n)")
par <- opar
```

Useful palettes have also been described specifically for cartography. http://colorbrewer2.org/ has palettes for seqential and qualitative diferences, and options for colourblind-safe and photocopy friendly palettes. You can use them via an R package:

```{r}
if (!require(RColorBrewer, quietly=TRUE)) {
  install.packages("RColorBrewer")
  library(RColorBrewer)
}
display.brewer.all()
```

Here, we apply a Brewer palette to a Voronoi tesselation of a point set.

```{r}
if (!require(deldir, quietly=TRUE)) {
  install.packages("deldir")
  library(deldir)
}
```

Create a point set along a logarithmic spiral, with a bit of added noise.
```{r}
li <- 0.1
n <- 45
dl <- 1.06
ncirc <- 13
da <- (2*pi)/ncirc
fnoise <-0.13
```


create a matrix of points
```{r}
x <- numeric(n)
x <- cbind(x, numeric(n))

set.seed(16180)
for (i in 1:n) {
	l <- li * (dl^(i-1))
	x[i,1] <- (l+(rnorm(1)*fnoise*l)) * cos((i-1)*da)
	x[i,2] <- (l+(rnorm(1)*fnoise*l)) * sin((i-1)*da)
}
plot(x[,1], x[,2])

```

```{r}
ts <- deldir(x[,1], x[,2])       # calculate the tesselation
tl <- tile.list(ts)      # calculate the list of tiles
plot.tile.list(tl)       # plot it
```


Let's colour the cells by distance from a defined point using a Brewer palette

```{r}
plot.tile.list(tl)       # plot it
points(x[25,1], x[25,2], pch=20, col="red")   # pick a point

vec <- c(x[25,1], x[25,2]) # define a point
```

define a function for Euclidian distance
```{r}
vDist <- function(x,v) { sqrt(sum((x-v)^2)) }  # calculates Euclidian distance
d <- apply(x, 1 , vDist, v=vec)                # apply this to the point set

dCol <- floor(((d-min(d))/(max(d)-min(d)) * 10)) + 1 # map d into 10 intervals
dCol[which(dCol>10)] <- 10                           # demote the largest one

pal <- brewer.pal(10, "RdGy")   # create the palette

# plot the tesselation, colour by palette
plot.tile.list(tl, fillcol = pal[dCol], cex=0.8, pch=20, col.pts="slategrey")
```




## Lines  ===============================================================

Basically all plots take arguments lty to define the line type, and lwd to define line width

```{r}
# empty plot ...
plot(c(0,10), c(0,10), type = "n", axes = FALSE, xlab = "", ylab = "")

# Line type
for (i in 1:8) {
	y <- 10.5-(i/2)
	segments(1,y,5,y, lty=i)
	text(6, y, paste("lty = ", i), col="grey60", adj=0, cex=0.75)
}

# Line width
for (i in 1:10) {
	y <- 5.5-(i/2)
	segments(1,y,5,y, lwd=(0.3*i)^2)
	text(6, y, paste("lwd = ", (0.3*i)^2), col="grey60", adj=0, cex=0.75)
}

```


##  Axes  
```{r}
# For Details, see:
?plot.default
```

```{r}
n <- 1000
x <- rnorm(n)
y <- x^3 * 0.25 + rnorm(n, sd=0.75)

plot(x,y)  # Default
```

```{r}
plot(x,y, xlim=c(-4, 4)) # fixed limits
```

```{r}
plot(x,y, xlim=c(-4, 4), ylim=c(10, -10)) # reverse is possible
```
```{r}
plot(x,y, log="xy") # log axes
```

The axis parameters in the default plot are limited. If you want more control, suppress the printing of an axis in the plot and use the axis() function instead.
```{r}
?axis
```

```{r}
# Axis-labels and title are straightforward parameters of plot
plot(x,y, xlab="rnorm(n)",
          ylab="x^3 * 0.25 + rnorm(n, sd=0.75)",
          cex.main=1.3,
          main="Sample\nPlot",
          cex.sub=0.75,
          col.sub="grey",
          sub="Scatterplot of noisy 3d-degree polynomial"
          )
```

Add gridlines

```{r}
?grid
plot(x,y, xlab="rnorm(n)",
          ylab="x^3 * 0.25 + rnorm(n, sd=0.75)",
          cex.main=1.3,
          main="Sample\nPlot",
          cex.sub=0.75,
          col.sub="grey",
          sub="Scatterplot of noisy 3d-degree polynomial"
          )
grid()
```


##   Layout 

### par, lattice, constant aspect ratio

Most parameters of the plot window can be set via the functions plot(), hist() etc., but some need to be set via the par() function. Calling par() without arguments lists the current state of the plotting parameters. Calling it with arguments, returns the old parameters and sets new parameters. Thus setting new parameters and saving the old ones can be done in one step. The parameters that have to be set via

par include:

  * multiple plots in one window (mfrow, mfcol, mfg)
  * margin layout (mai, mar mex, oma, omd, omi)
  * controlling position and size of a plot in the figure (fig, plt, ps, pty)
  * see ?par for details.

```{r}
n <- 1000
x <- rnorm(n)
y <- x^3 * 0.25 + rnorm(n, sd=0.75)
```


```{r}
# set window background and plotting axes via par
opar <- par(bg="steelblue", fg="lightyellow")
# set axis lables and titles via plot parameters
plot(x,y, col.axis="lightyellow", col.lab="lightyellow")
par(opar)  # rest to old values

plot(x,y) # confirm reset
```



##  Plot symbols and text 

Plot symbols are defined in the pch argument to plot(). id 1:20 are regular symbols

```{r}
# Empty plot frame ...
plot(c(0,10), c(0,10), type = "n", axes = FALSE, xlab = "", ylab = "")

# coordinates for first 25 symbols
x1 <- rep(0.5:9.5, 2)[1:20]
y1 <- sort(rep(9.5:8.5, 10), dec=TRUE)[1:20]
points(x1, y1, pch=1:20)

```

```{r}
# Empty plot frame ...
plot(c(0,10), c(0,10), type = "n", axes = FALSE, xlab = "", ylab = "")

# id 21:25 can have different border and fill colours
x2 <- 0.5:4.5
y2 <- rep(7.5,5)
points(x2, y2, pch=21:25, col="slategrey", bg=rainbow(5))
```

```{r}
# Empty plot frame ...
plot(c(0,10), c(0,10), type = "n", axes = FALSE, xlab = "", ylab = "")

# ten extra symbols are defined as characters
x3 <- 0.5:9.5
y3 <- rep(6.5,10)
extra = c(".", "o", "O", "0","a","A", "*", "+","-","|")
points(x3, y3, pch=extra) # note: ext is a character vector

```

```{r}
# Empty plot frame ...
plot(c(0,10), c(0,10), type = "n", axes = FALSE, xlab = "", ylab = "")

# The ASCII codes for characters 32 to 126 can also be used as plotting symbols
x4 <- rep(seq(0.5,9.5,0.5), 5)[1:96]
y4 <- sort(rep(5.5:0.5, 19), dec=TRUE)[1:96]
points(x4, y4, pch=32:126, col="navyblue")
```

Plotting arbitrary text use the text() function to plot characters and strings to coordinates

```{r}
?text
```


```{r}

# Empty plot frame ...
plot(c(0,10), c(0,10), type = "n", axes = FALSE, xlab = "", ylab = "")

# Example: add labels to the symbols
# first set: plain symbols (1 to 20)
text(x1-0.4, y1, paste(1:20), cex=0.75)
# symbols with separate background (21 to 25)
text(x2-0.4, y2, paste(21:25), cex=0.75)
# third set: special characters, change font for clarity
text(x3-0.4, y3, extra, col="slateblue", cex=0.75, vfont=c("serif", "plain"))

```

a large set of Hershey vector fonts is available which gives access to many more plotting and labeling options via text()
```{r}
demo(Hershey)
```



Plotting other symbols:
In the most general way, Unicode characters can be plotted as text. The code is passed in hexadecimal, long integer, with a negative sign. Here is a quarter note (Unicode: 266a) using plot()
```{r}
plot(0.5,0.5, pch=-0x266aL, cex=5, xlab="", ylab="")
```

However, rendering varies across platforms since it depends on unicode support. It is safer to use the inbuilt Hershey vector fonts.


## Drawing on plots 

  * abline()
  * segments()
  * lines()
  * arrows() ... but to get a filled arrow use polygon()

Example: dividing a plot into 60° regions, centred on a point. A general approach to "lines" on a plot is provided by segments(). However in this special case one can use abline(). We have to take care though that the aspect ratio for the plot is exactly 1 - otherwise our angles are not right. Therefore we need to set the asp parameter for plots.

For a general sketch
  * we plot the frame a bit larger, don't draw axes
  * draw the ablines
  * draw two arrows to symbolize the coordinate axes

```{r}
p <- c(4, 2)
plot(p[1], p[2],
     xlim=c(-0.5,10.5),
     ylim=c(-0.5,10.5),
     xlab="", ylab="",
     axes=FALSE,
     asp=1.0)
abline(h=p[2], lty=2)  # horizontal
abline(p[2] - (p[1]*tan(pi/3)),  tan(pi/3), lty=2)  # intercept, slope
abline(p[2] + (p[1]*tan(pi/3)), -tan(pi/3), lty=2)  # intercept, slope
arrows(0, 0, 10, 0, length=0.1)   # length of arrow
arrows(0, 0, 0, 10, length=0.1)
```



  * curves()
  * rect()
  * polygon()
  * More: see the Index of functions for the graphics package

## Special packages

Packages in the standard distribution:

   * use with library("package")
   * graphics

   * grid

   * lattice

Packages that can be downloaded from CRAN:

   * use with install.packages("package"), then library("package")
            
   * hexbin
   * ggplot2

Packages that can be downloaded  from BioConductor
   * prada:
```{r}
if (!requireNamespace("prada", quietly = TRUE)){
     install.packages("BiocManager")
   }
     BiocManager::install("prada")
```


#      Try:
```{r}
n <- 1000
x <- rnorm(n)
y <- x^3 * 0.25 + rnorm(n, sd=0.75)
# smoothed scatterplot with outliers
smoothScatter(x,y, nrpoints=200, pch=20, cex=0.5, col="#6633BB55")
```


```{r}
# density adapted colours
plot (x, y, col=densCols(x,y), pch=19, cex=1.5)
```

## Self-evaluation

## Further reading, links and resources
 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2018-05-05<br>
Version: 1.0.1<br>
**Version history**:<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:12-R-plotting.Rmd-->

# R Coding Style {#r-code-style}
(R coding style; software development)

## Overview
### Abstract:
Now that you have encountered some concepts of R programming, how do you write good R code?

### Objectives:

This unit will:

  * introduce tried and proven principles of writing expressive and maintainable R code.

### Outcomes:

After working through this unit you:

  * can identify poor practice in formatting R code;
  * know better;
  * begin incorporating these principles into your own practice.

### Deliverables:
**Time management**: Before you begin, estimate how long it will take you to complete this unit. Then, record in your course journal: the number of hours you estimated, the number of hours you worked on the unit, and the amount of time that passed between start and completion of this unit.

**Journal**: Document your progress in your Course Journal. Some tasks may ask you to include specific items in your journal. Don't overlook these.

**Insights**: If you find something particularly noteworthy about this unit, make a note in your insights! page.

### Prerequisites 
[RPR-Plotting (Introduction to R Plots)](#r-plots)


What do we even mean by "good" R code? ...

```{block type="rmd-caution"}
Warning: Coding style is a volatile topic. Friendships have been renounced, eternal vows of marriage have been dissolved, stock-options have been lost, all over a disagreement about the One True Brace Style, or whether fetchSequenceFromPDB()is a good function name or not. I am laying out coding rules below that reflect a few years of experience. They work for me, they may not work for you.
```

However:

  * If you are taking one of my workshops, I recommend you to follow these rules: I write this way, and we will find it easier to communicate if you do too.
  * If you are collaborating on a software project, these rules embody the standard across the project, and I will not check-in code that deviates. Here, consistency is key; but if you think you have a better approach, you only need to convince me and we will change the rule and apply it throughout the codebase^[I'm serious: I have reformatted major pieces of code more than once after learning of a better approach, and if that creates better code it is very satisfying.].
  *If you are taking one of my courses, you may lose marks if you do not adhere to these standards. Of course, following rules must not be done blindly – we are training future collaborators, not parrots – but you need to write in the spirit of the one rule we all agree on:

Well written code helps the reader to understand the intent.

## General

One of the goals of the coding style expressed below is that it should be easy to read for people for whom R is not the first language, or even the language of choice. There are many things that R-purists might do differently, however those probably are not well suited for a research collaboration in which people speak python, C++, javascript and R all at the same time.

It should always be your goal to code as clearly and explicitly as possible. R has many complex idioms, and since it is a functional language that can generally insert functions anywhere into expressions, it is possible to write very terse, expressive code. Use this with discretion. Pace yourself, and make sure your reader can follow your flow of thought. You should aim for a generic coding style that can easily be translated to other languages if necessary, and easily understood by others whose background is in another language. And resist being crafty: more often than not the poor soul who will be confused by a particularly witty use of the language will be you, yourself, half a year later. There is an astute observation by Brian Kernighan that applies completely:

"Debugging is twice as hard as writing the code in the first place. Therefore, if you write the code as cleverly as possible, you are, by definition, not smart enough to debug it."

Never sacrifice being explicit for saving on keystrokes. Code is read much more often than it is written!

Use lots of comments. Don't describe what the code does, but explain why you wrote it that way.

Indent comment "#"-characters to align with the expressions in a block.

Use only <- for assignment, not =

...but do use = when passing values into the arguments of functions.

Define global variables at the beginning of the code, use all caps variable names (MAXWIDTH) for such parameters. Never have "magic numbers" appear in your code.

If such variables are meant to be truly global use options() to set them.

Always use for (i in seq(along=x)) {...} rather than for (i in 1:length(x)) {...} because if x == NULL the loop is executed once, with an undefined variable.

Don't use attach().

Avoid importing functions wholesale from packages with library(). Rather use the <package>::<function>() syntax to make it clear which function you mean^[It is happening more and more frequently that functions in different packages we load have the same name. Then our code's behaviour will depend on the order in which the libraries were loaded. Evil.]. That's what package namespaces are for in the first place.

Bad:

library(igraph)
 
...
 
...
 
clu <- components(g)
Good:

clu <- igraph::components(g)

Don't change the global state
 
We do understand why our functions should not have side-effects (other than the explicit intended effects of printing, plotting, or writing files). But there are subtle ways to change the global state that we need to remember - and avoid. Here's an obvious one:

Don't use <<- (global assignment) except in very unusual cases. Actually never.
Less obvious is:

Don't use set.seed() in functions.

set.seed() changes the state of the Random Number Generator (RNG), which is part of Rs global state. If this state is changed inside a function, it might result in vastly smaller space of random numbers than you would expect. Even resetting the RNG is not a good idea: a repeatable script might require the RNG to be in a defined state and if your function does set.seed(NULL), your enclosing script is no longer repeatable. But of course, we need to be able to compute simulations repeatably. The only acceptable idiom is something like:

mySim <- function(N) { ...
  # do something random N times
  return(result)
}
 
set.seed(112358)                       # set RNG seed for repeatable randomness
x <- mySim(N)
set.seed(NULL)                         # reset the RNG

Then you can comment out the lines, or change them to a different seed, or reset the RNG with set.seed(NULL) - everything is explicit.


## Layout

Limit yourself to 80 characters per line.

Don't use semicolons to write more than one expression on a line.

 
## Design and granularity

  * Don't repeat code. Use functions instead.
  * Don't repeat code. If you feel the urge to type code more than once, that's how you know you should break up the code into functions.
  * Don't repeat code. I'm repeating this for emphasis.

One of the general principles of writing clear, maintainable code is collocation. This means that information items that can affect each other should be viewable on the same screen. Spolski makes a great argument for this, together with a few excellent examples; he also makes a case for a special kind of prefix notation for variable and function names that has a lot of merit.


If the code for a function does not fit on approxiamtaley one printed page, you should probably break it up further.

if your loops or conditionals are nested more than three levels deep, you should rethink the logic. Actually three is already a lot. Unless you are working on 3D-objects.

 
## Headers

Give your script files headers that state purpose, author, date and version information, and note bugs and issues.

Give your functions headers that describe purpose, parameters (including required datatypes), and return values. Callers should be able to work with the function without having to read the code.

 
## Sections

Use separators (# --- SECTION -----------------) to structure your code.

 
## Parentheses and Braces

In mathematical expressions, always use parentheses to define priority explicitly. Never rely on implicit operator priority. (( 1 + 2 ) / 3 ) * 4

Always use braces {}, even if you write single-line if statements and loops.

 
## Spaces

if and for are language keywords, not functions. Separate the following parenthesis from the keyword with a space.

Good:

if (silent) { ...

Bad:

if(silent) { ...

Always separate operators and arguments with spaces.^[Separating operators with spaces is especially important for the assignment operator <-. Consider this: myPreciousData < -2 returns a vector of TRUE and FALSE, depending on whether the values in myPreciousData are less than -2. But myPreciousData<-2 overwrites every single element with the number 2! I'm not even making this up - happened to a student in a workshop I taught.]^[The = sign is a bit of a special case. When I write e.g. a plot statement, or construct a dataframe, I prefer not to use spaces if the expression ends up all on one line, but to use spaces when the arguments are on separate lines.]

Never separate function names and their following parentheses with spaces.

Always use a space after a comma, and never before a comma. Except in subsetting expressions, where we don't want the comma to hide against the bracket.

Good:

print(1 / 3, digits = 10)
if (! id %in% IDs) { ...'
expressionProfiles[ , 1:3]

Bad:

print (1 / 3 ,digits=10)
if (!id %in% IDs) { ...
expressionProfiles[, 1:3]

 
## Names

There are only two hard things in Computer Science: cache invalidation and naming things.

- Phil Karlton^[For a complementary perspective, [see here](http://thecodelesscode.com/case/220).]

Use informative and specific filenames for code sources; give them the extension .R

Periods have a syntactic meaning in object-oriented classes. I consider their use in normal variables names wrong, even though this is not a syntax error and many R library functions have such names (e.g. Sys.time() and other system calls.)

Create names so that related variables or functions are alphabetically sorted together, code autocomplete will be more useful.

Use the concise camelCaseStyle for variable names, don't use the confusing.dot.style or the rambling pothole_style^[But nevert hesitate to make exceptions if this makes your code more legible.]^[This is not a random opinion but based on that it's easier to keep within the 80-character line limit. Also see the [linked article](http://citeseerx.ist.psu.edu/viewdoc/similar?doi=10.1.1.158.9499&type=ab)].

Don't abbreviate argument names when calling functions. You can, but you shouldn't.

Never reassign reserved words^[In my opinion, base R uses far too many function names that would be useful for variables. But we're not going to change that. So I often just prefix my variable names with my- or this-, eg myDf, thisLength etc.].

Don't use c as a variable name since c() is a function.

Don't call your data frames df since df() is a function.^[Here are more names that may seem attractive as variable names but that are in fact functions in the base R package and thus may cause confusion: all(), args(), attr(), beta(), body(), col(), date(), det(), diag(), diff(), dim(), dir(), dump(), eigen(), file(), files(), gamma(), kappa(), length(), list(), load(), log(), max(), mean(), min(), open(), q(), raw(), row(), sample(), seq(), sub(), summary(), table(), type(), url(), vector(), and version(). I'm sure you get the idea - composite names of the type proposed above in CamelCase are usually safe.]

Name length should be commensurate with the scope of a variable. Short names for local scope. More explicit names for global scope. I often write global parameters in ALL CAPS: MAXWIDTH if they are defined at the top of a code module.

Specific naming conventions I like:

  * isValid, hasNeighbour ... Boolean variables
  * findRange(), getLimits() ... simple function names (verbs!)
  * initializeTable() ... not initTab()
  * Use plurals to good advantage. node ... for one element; nodes ... for more elements - you can then write code like:
  * for (node in nodes) { ...
  * nPoints ... for number-of
  * iPoints ... for indices-of-points
  * isError ... don't use isNotError: avoid double negation

 
## Conditionals

This may be controversial. The code block in an if (<condition>) {...} statement is evaluated if <condition> is TRUE. But what if we use a boolean variable in the condition? 

Should we write:

if (<boolean variable>) { ...

or

if (<boolean variable> == TRUE) { ...

It depends. Remember - the goal is to make your code as explicit and readable as possible. 

If our variable is e.g. a, then ...

if (a) { ...
... is not good. Better write ...

if (a == TRUE) { ...
... and treat this as any other condition that needs to be evaluated. However - if you have given this a meaningful variable name in the first place, something like ...

if (recordIsValid) { ...
... is great, whereas ...

if (recordIsValid == TRUE) { ...
... is something that feels oddly self-contradictory. So best practice here depends on context. Myself, I more often than not end up write if (something-something-that-is-boolean == TRUE) ..., (and that's not because I don't understand how conditionals work).

Make the FALSE behaviour explicit. Always use an else at the end of a conditional to define what your code does if the condition is not TRUE. Otherwise your reader will wonder whether your code covers all cases. What if your code should do nothing in the FALSE case? Make that explicit:

if (a > b) {
  tmp <- b
  b <- a
  a <- tmp
} else {
  ;
}

Instead of the lone semicolon you could also write NULL, or invisible(NULL).


 
## Indent Style

No need for much discussion. Follow the One True Bracing Style and we will all be happy. If you don't immediately see why: read about indent style here. (1) Opening brace on the same line as the function or control declaration; (2) closing brace aligned with the declaration; (3) braces mandatory even if there is only one statement to execute. Sample:

if (length(x) > 1) {
  perm <- sample(x)
} else if (length(x) > 0) {
  perm <- x
} else  {
  perm <- NULL
}

## Indentation of long function declarations

Use spaces to align repeating parts of code, so errors become easier to spot.

 
## Loops

Pre-allocate your result objects to have the correct size if at all possible. Growing objects dynamically with c(), cbind(), or rbind() is much, much slower.

Use seq_along(), not length() to compute the range of index variables. If the object you are iterating over has length zero (i.e. it is NULL, like e.g. the result of a grep() operation if the pattern was not found) then using ...

for (idx in 1:length(myVector)) { ...
... will result in an iteration range of 1:0 since length(NULL) is zero, and the loop will be executed twice even though it should not have been. The correct and safe way to iterate is ...

for (idx in seq_along(myVector)) { ...
... which will not execute since seq_along(NULL) is NULL.


 
## Functions

Explicitly assign values to crucial function arguments, even if you think you know that that value is the language default. For example ...
sort(x)
... sorts in increasing order, smallest first. But even though ...

sort(x, decreasing = FALSE)
... does the same thing, the expression explicitly tells the reader what it is going to do. And that's good.

Always explicitly return values from functions, never rely on the implicit behaviour that returns the last expression. This is not superfluous, it is explicit.

If there is nothing to return because the function is invoked for its side effects of writing a file or plotting a graph, write it into your code that nothing will be returned. This prevents you from accidentally returning the result of last expression anyway (as the language does by default), or the reader might think you forgot something. The idiom is:
return(invisible(NULL))

In general, return only from the end of the function, not from multiple places.

 
## Efficiency

If possible, do not grow data structures dynamically, but create the whole structure with "empty" values, then assign values to its elements. This is much faster.

```{r}
# This is really bad:
 system.time({
   N <- 100000
   v <- numeric()
   for (i in 1:N) {
       v <- c(v, sqrt(i))
   }
 })

```
 
 
```{r}
 
 # Even only writing directly to new elements is much, much better:
 system.time({
   N <- 100000
   v <- numeric()
   for (i in 1:N) {
       v[i] <- sqrt(i)
   }
 })
```
 
```{r}
# That's abaout as fast as doing the same thing with a vapply() function.
 
 # The fastest way is to preallocate memory, it actually comes close to the
 # vectorized operation:
 
 system.time({
   N <- 100000
   v <- numeric(N)
   for (i in seq_along(v)) {
       v[i] <- sqrt(i)
   }
 })
```

```{r}
# Using a vectorized operation is the fastest approach overall and the
# method of choice:
 
system.time({ v <- sqrt(1:100000) })
```
  
Don't buy into the "apply good, for-loop bad" nonsense. Especially not if you need speed: a well-written for-loop will outperform an apply() statement, which internally uses a for-loop anyway. The reason we often use apply() is because we are following a functional programming idiom, not because there is something magical and exalted about the apply() function. It's usually a bit subtle which idiom is "better" at any given time.


 
## [END]
Always end your code with an # [END] comment. This way you can be sure it was copied or saved completely and nothig has been inadvertently omitted. This is important in teamwork. If even ONE team member does not adhere to this, it invalidates the efforts of EVERYONE.

 

## Self-evaluation

## Further reading, links and resources
  * [Google's R Style Guide](https://google.github.io/styleguide/Rguide.html)
  * [Jenny Bryan has very useful comments on how style supports coding](https://www.stat.ubc.ca/~jenny/STAT545A/block19_codeFormattingOrganization.html)
  * [XKCD on Code Quality](https://xkcd.com/1513/)
  * R source code itself is largely based on the [GNU coding standards](https://www.gnu.org/prep/standards/standards.html)
  * [Tim Ottinger on Naming](http://agileinaflash.blogspot.com/2009/02/meaningful-names.html)
  * [Joel Spolski on collocation](https://www.joelonsoftware.com/2005/05/11/making-wrong-code-look-wrong/)


**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2019-04-12<br>
Version: 1.1.1<br>
**Version history**:<br>
1.1.1 Maintenance<br>
1.1 Add: Dont change the global state; Avoid library()<br>
1.0.1 Maintenance<br>
1.0 Completed to first live version<br>
0.1 Material collected from previous tutorial<br>
``` 


### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:13-R-code-style.Rmd-->

#Introduction to R {#r-intro}
(Introduction to R)

##Overview
### Abstract:
This page collects the learning units for an introduction to R.

### Objectives:
...

### Outcomes:
...

### Deliverables:
No separate deliverables: This unit collects other units and has no deliverables on its own.

### Prerequisites:
This unit builds on material covered in the following prerequisite units:

[RPR-Coding_style (R Coding Style)](#r-code-style)

This is a "milestone unit". Its purpose is merely to collect a number of preparatory units into a single, common prerequisite. It has no contents of its own; you are expected to be familiar and competent with all preparatory material at this point.

## The ABC RStudio Project

**R**-scripts and other resources for the learning units of this course are collected in an RStudio project. This makes it easy to update and distribute code. I push update material to the GitHub repository of the project for any unit, all you need to do is to pull the updated project to receive all updates and new files on your computer. Version control is really useful for this. However, there is an issue that you need to be aware of. If you create your own, local files and then commit them, git will complain that it would be overwriting such local material. As long as you don't commit your files then all should be fine. This means you'll need to do your own "versioning" by saving your own scripts under a different name from time to time. Once again: in this context:

  * saving your own files is fine;
  * committing your own files to version control will cause problems;
  * changes you make to course material files and save under the same filename (like adding comments and notes) will not persist, these changes will be overwritten with the next update. You need to "Save As..." with a new filename (for example, prefix the original name with "my").

`r task_counter <- task_counter + 1`
## Task `r task_counter`
 
```{block, type="rmd-task"}
  * Open RStudio and create a New Project... cloned from a git version control directory. The repository URL is https://github.com/hyginn/ABC-units. Create this in the same way as you did for the R-tutorial.
  * As requested on the console, type init(). This will create a file called .myProfile.R and ask you for your UofT eMail address and Student ID. You need to enter the correct values because other scripts will assume that these variables exist and are valid.
  * Work through the task: "Local script" in the RPR-Introduction.R script.
```
 
## Self-evaluation
  * Understanding the setup
    * Imagine you made a typo when you entered your eMail address and now the file .myProfile.R contains a mistake. How do you fix this?^[.myProfile.R is itself a file in the local working directory. Simply open it with the RStudio editor, fix the error, and save. Then type source(".myProfile.R") into the console to overwrite the old (wrong) definition with the corrected one.]

 [Expand] 
Answer ...

## Further reading, links and resources
 
**If in doubt, ask!**<br>
If anything about this learning unit is not clear to you, do not proceed blindly but ask for clarification. Post your question on the course mailing list: others are likely to have similar problems. Or send an email to your instructor.

```{block2, type="rmd-original-history"}
<br>**Author**: Boris Steipe <boris.steipe@utoronto.ca> <br>
**Created**: 2017-08-05<br>
**Modified**: 2017-08-05<br>
Version: 1.0<br>
**Version history**:<br>
1.0 Completed to first live version.<br>
0.1 First stub<br>
``` 
 

### Updated Revision history
```{r echo=FALSE}
source("./bcb420_books_helper_functions.R")
knitr::kable(githistory2table(git2r::commits(repo=".",path=knitr::current_input())))

```

### Footnotes:

<!--chapter:end:14-R-Intro.Rmd-->

